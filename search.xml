<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[如何做到jQuery-free?]]></title>
      <url>http://yoursite.com/2016/06/21/%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0jQuery-free/</url>
      <content type="html"><![CDATA[<h1 id="如何做到-jQuery-free？"><a href="#如何做到-jQuery-free？" class="headerlink" title="如何做到 jQuery-free？"></a>如何做到 jQuery-free？</h1><p>jQuery是现在最流行的JavaScript工具库。</p>
<p>据统计，目前全世界57.3%的网站使用它。也就是说，10个网站里面，有6个使用jQuery。如果只考察使用工具库的网站，这个比例就会上升到惊人的91.7%。</p>
<p>虽然jQuery如此受欢迎，但是它臃肿的体积也让人头痛不已。jQuery 2.0的原始大小为235KB，优化后为81KB；如果是支持IE6、7、8的jQuery 1.8.3，原始大小为261KB，优化后为91KB。</p>
<p>这样的体积，即使是宽带环境，完全加载也需要1秒或更长，更不要说移动设备了。这意味着，如果你使用了jQuery，用户至少延迟1秒，才能看到网页效果。考虑到本质上，jQuery只是一个操作DOM的工具，我们不仅要问：如果只是为了几个网页特效，是否有必要动用这么大的库？<br><a id="more"></a></p>
<p>2006年，jQuery诞生的时候，主要用于消除不同浏览器的差异（主要是IE6），为开发者提供一个简洁的统一接口。相比当时，如今的情况已经发生了很大的变化。IE的市场份额不断下降，以ECMAScript为基础的JavaScript标准语法，正得到越来越广泛的支持。开发者直接使用JavScript标准语法，就能同时在各大浏览器运行，不再需要通过jQuery获取兼容性。</p>
<p>下面就探讨如何用JavaScript标准语法，取代jQuery的一些主要功能，做到jQuery-free。</p>
<h2 id="一、选取DOM元素"><a href="#一、选取DOM元素" class="headerlink" title="一、选取DOM元素"></a>一、选取DOM元素</h2><p>jQuery的核心是通过各种选择器，选中DOM元素，可以用querySelectorAll方法模拟这个功能。<br>　　var $ = document.querySelectorAll.bind(document);<br>这里需要注意的是，querySelectorAll方法返回的是NodeList对象，它很像数组（有数字索引和length属性），但不是数组，不能使用pop、push等数组特有方法。如果有需要，可以考虑将Nodelist对象转为数组。<br>　　myList = Array.prototype.slice.call(myNodeList);</p>
<h2 id="二、DOM操作"><a href="#二、DOM操作" class="headerlink" title="二、DOM操作"></a>二、DOM操作</h2><p>DOM本身就具有很丰富的操作方法，可以取代jQuery提供的操作方法。<br>尾部追加DOM元素。</p>
<pre><code>// jQuery写法
$(parent).append($(child));
// DOM写法
parent.appendChild(child)
</code></pre><p>头部插入DOM元素。</p>
<pre><code>// jQuery写法
$(parent).prepend($(child));
parent.insertBefore(child, parent.childNodes[0])
</code></pre><p>删除DOM元素。</p>
<pre><code>// jQuery写法
$(child).remove()
// DOM写法
child.parentNode.removeChild(child)
</code></pre><h2 id="三、事件的监听"><a href="#三、事件的监听" class="headerlink" title="三、事件的监听"></a>三、事件的监听</h2><p>jQuery的on方法，完全可以用addEventListener模拟。</p>
<pre><code>Element.prototype.on = Element.prototype.addEventListener;
</code></pre><p>为了使用方便，可以在NodeList对象上也部署这个方法。</p>
<pre><code>NodeList.prototype.on = function (event, fn) {
　　[][&apos;forEach&apos;].call(this, function (el) {
　　　　el.on(event, fn);
　　});
　return this;
};
</code></pre><p>四、事件的触发<br>jQuery的trigger方法则需要单独部署，相对复杂一些。</p>
<pre><code>Element.prototype.trigger = function (type, data) {
　　var event = document.createEvent(&apos;HTMLEvents&apos;);
　event.initEvent(type, true, true);
　　event.data = data || {};
　　event.eventName = type;
　　event.target = this;
  　this.dispatchEvent(event);
    　return this;
};
</code></pre><p>在NodeList对象上也部署这个方法。</p>
<pre><code>NodeList.prototype.trigger = function (event) {
　　[][&apos;forEach&apos;].call(this, function (el) {
　　　el[&apos;trigger&apos;](event);
　});
　　return this;
};
</code></pre><h2 id="五、document-ready"><a href="#五、document-ready" class="headerlink" title="五、document.ready"></a>五、document.ready</h2><p>目前的最佳实践，是将JavaScript脚本文件都放在页面底部加载。这样的话，其实document.ready方法（jQuery简写为$(function)）已经不必要了，因为等到运行的时候，DOM对象已经生成了。</p>
<h2 id="六、attr方法"><a href="#六、attr方法" class="headerlink" title="六、attr方法"></a>六、attr方法</h2><p>jQuery使用attr方法，读写网页元素的属性。</p>
<pre><code>$(&quot;#picture&quot;).attr(&quot;src&quot;, &quot;http://url/to/image&quot;);
</code></pre><p>DOM元素允许直接读取属性值，写法要简洁许多。</p>
<pre><code>$(&quot;#picture&quot;).src = &quot;http://url/to/image&quot;;
</code></pre><p>需要注意，input元素的this.value返回的是输入框中的值，链接元素的this.href返回的是绝对URL。如果需要用到这两个网页元素的属性准确值，可以用</p>
<pre><code>this.getAttribute(&apos;value&apos;)和this.getAttibute(&apos;href&apos;)。
</code></pre><h2 id="七、addClass方法"><a href="#七、addClass方法" class="headerlink" title="七、addClass方法"></a>七、addClass方法</h2><p>jQuery的addClass方法，用于为DOM元素添加一个class。</p>
<pre><code>$(&apos;body&apos;).addClass(&apos;hasJS&apos;);
</code></pre><p>DOM元素本身有一个可读写的className属性，可以用来操作class。</p>
<pre><code>document.body.className = &apos;hasJS&apos;;
// or
document.body.className += &apos; hasJS&apos;;
</code></pre><p>HTML 5还提供一个classList对象，功能更强大（IE 9不支持）。</p>
<pre><code>document.body.classList.add(&apos;hasJS&apos;);
document.body.classList.remove(&apos;hasJS&apos;);
document.body.classList.toggle(&apos;hasJS&apos;);
document.body.classList.contains(&apos;hasJS&apos;);
</code></pre><h2 id="八、CSS"><a href="#八、CSS" class="headerlink" title="八、CSS"></a>八、CSS</h2><p>jQuery的css方法，用来设置网页元素的样式。</p>
<pre><code>$(node).css( &quot;color&quot;, &quot;red&quot; );
</code></pre><p>DOM元素有一个style属性，可以直接操作。</p>
<pre><code>element.style.color = &quot;red&quot;;;
// or
element.style.cssText += &apos;color:red&apos;;
</code></pre><h2 id="九、数据储存"><a href="#九、数据储存" class="headerlink" title="九、数据储存"></a>九、数据储存</h2><p>jQuery对象可以储存数据。</p>
<pre><code>$(&quot;body&quot;).data(&quot;foo&quot;, 52);
</code></pre><p>HTML 5有一个dataset对象，也有类似的功能（IE 10不支持），不过只能保存字符串。</p>
<pre><code>element.dataset.user = JSON.stringify(user);
element.dataset.score = score;
</code></pre><h2 id="十、Ajax"><a href="#十、Ajax" class="headerlink" title="十、Ajax"></a>十、Ajax</h2><p>jQuery的Ajax方法，用于异步操作。</p>
<pre><code>$.ajax({
　　type: &quot;POST&quot;,
　　url: &quot;some.php&quot;,
　　data: { name: &quot;John&quot;, location: &quot;Boston&quot; }
}).done(function( msg ) {
　　alert( &quot;Data Saved: &quot; + msg );
});
</code></pre><p>我们可以定义一个request函数，模拟Ajax方法。</p>
<pre><code>function request(type, url, opts, callback) {
　　var xhr = new XMLHttpRequest();
　　if (typeof opts === &apos;function&apos;) {
　　　　callback = opts;
　　　　opts = null;
　　}
　　xhr.open(type, url);
　　var fd = new FormData();
　　if (type === &apos;POST&apos; &amp;&amp; opts) {
　　　　for (var key in opts) {
　　　　　　fd.append(key, JSON.stringify(opts[key]));
　　　　}
　　}
　　xhr.onload = function () {
　　　　callback(JSON.parse(xhr.response));
　　};
　　xhr.send(opts ? fd : null);
}
</code></pre><p>然后，基于request函数，模拟jQuery的get和post方法。</p>
<pre><code>var get = request.bind(this, &apos;GET&apos;);
var post = request.bind(this, &apos;POST&apos;);
</code></pre><p>　　## 十一、动画<br>jQuery的animate方法，用于生成动画效果。</p>
<pre><code>$foo.animate(&apos;slow&apos;, { x: &apos;+=10px&apos; })；
</code></pre><p>jQuery的动画效果，很大部分基于DOM。但是目前，CSS 3的动画远比DOM强大，所以可以把动画效果写进CSS，然后通过操作DOM元素的class，来展示动画。</p>
<pre><code>foo.classList.add(&apos;animate&apos;)；
</code></pre><p>如果需要对动画使用回调函数，CSS 3也定义了相应的事件。</p>
<pre><code>el.addEventListener(&quot;webkitTransitionEnd&quot;, transitionEnded);
el.addEventListener(&quot;transitionend&quot;, transitionEnded);
</code></pre><h2 id="十二、替代方案"><a href="#十二、替代方案" class="headerlink" title="十二、替代方案"></a>十二、替代方案</h2><p>由于jQuery体积过大，替代方案层出不穷。</p>
<p>其中，最有名的是zepto.js。它的设计目标是以最小的体积，做到最大兼容jQuery的API。zepto.js 1.0版的原始大小是55KB，优化后是29KB，gzip压缩后为10KB。<br>如果不求最大兼容，只希望模拟jQuery的基本功能，那么，min.js优化后只有200字节，而dolla优化后是1.7KB。</p>
<p>此外，jQuery本身采用模块设计，可以只选择使用自己需要的模块。具体做法参见它的github网站，或者使用专用的Web界面。</p>
<h2 id="十三、参考链接"><a href="#十三、参考链接" class="headerlink" title="十三、参考链接"></a>十三、参考链接</h2><p>　　- Remy Sharp，I know jQuery. Now what?<br>　　- Hemanth.HM，Power of Vanilla JS<br>　　- Burke Holland，5 Things You Should Stop Doing With jQuery<br>（完）</p>
<h3 id="文章转载自-lt-阮一峰博客-gt"><a href="#文章转载自-lt-阮一峰博客-gt" class="headerlink" title="文章转载自&lt;阮一峰博客&gt;"></a>文章转载自<a href="http://www.ruanyifeng.com/blog/2013/05/jquery-free.html" target="_blank" rel="external">&lt;阮一峰博客&gt;</a></h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一些蛋疼的JavaScript语法特性面试题]]></title>
      <url>http://yoursite.com/2016/05/23/%E4%B8%80%E4%BA%9B%E8%9B%8B%E7%96%BC%E7%9A%84JavaScript%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>JavaScript有很多地方和我们熟知的C、Java等的编程习惯不同，这些不同会产生很多让人意想不到的事情。前段时间在知乎有人发了写Javascrtip试题，觉得挺好玩的，这里跟大家分享一下。<br><a id="more"></a></p>
<h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><pre><code>(function () { 
    return typeof arguments; 
})(); 
A. &quot;object&quot;
B. &quot;array&quot;
C. &quot;arguments&quot;
D. &quot;undefined&quot;
</code></pre><p><code>答案：A</code></p>
<h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><pre><code>var f = function g() {
        return 23;
    };
typeof g();
A. &quot;number&quot;
B. &quot;undefined&quot;
C. &quot;function&quot;
D. Eorror
</code></pre><p><code>答案：D</code></p>
<h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><pre><code>(function (x) {
    delete x;
    return x;
})(1);
A. 1
B. null
C. undefined
D. Error
</code></pre><p><code>答案：A</code></p>
<h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><pre><code>var y = 1,
    x = y = typeof x;
x;
A. 1
B. &quot;number&quot;
C. undefined
D. &quot;undefined&quot;
</code></pre><p><code>答案： D</code></p>
<h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><pre><code>(function f(f) {
    return typeof f();
})(function () {
    return 1;
});
A. &quot;number&quot;
B. &quot;undefined&quot;
C. &quot;function&quot;
D. Error
</code></pre><p><code>答案：A</code></p>
<h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><pre><code>var foo = {
    bar: function () {
        return this.baz;
    },
    baz: 1
};
(function () {
    return typeof arguments[0]();
})(foo.bar);
A. &quot;undefined&quot;
B. &quot;object&quot;
C. &quot;number&quot;
D. &quot;function&quot;
</code></pre><p><code>答案：A</code></p>
<h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><pre><code>var foo = {
    bar: function () {
        return this.baz;
    },
    baz: 1
};
typeof (f = foo.bar)();
A. &quot;undefined&quot;
B. &quot;object&quot;
C. &quot;number&quot;
D. &quot;function&quot;
</code></pre><p><code>答案：A</code></p>
<h3 id="08"><a href="#08" class="headerlink" title="08"></a>08</h3><pre><code>var f = (function f() {
    return &quot;1&quot;;
}, function g() {
    return 2;
})();
typeof f;
A. &quot;string&quot;
B. &quot;number&quot;
C. &quot;function&quot;
D. &quot;undefined&quot;
</code></pre><p><code>答案： B</code></p>
<h3 id="09"><a href="#09" class="headerlink" title="09"></a>09</h3><pre><code>var x = 1;
if (function f() {}) {
    x += typeof f;
}
x;
A. 1
B. &quot;1function&quot;
C. &quot;1undefined&quot;
D. NaN
</code></pre><p><code>答案： C</code></p>
<h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><pre><code>var x = [typeof x, typeof y][1];
typeof typeof x;
A. &quot;number&quot;
B. &quot;string&quot;
C. &quot;undefined&quot;
D. &quot;object&quot;
</code></pre><p><code>答案： B</code></p>
<h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><pre><code>(function (foo) {
    return typeof foo.bar;
})({
    foo: {
        bar: 1
    }
});
A、“undefined”
B、“object”
C、“number”
D、Error
</code></pre><p><code>答案： A</code></p>
<h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><pre><code>(function f() {
    function f() {
        return 1;
    }
    return f();
    function f() {
        return 2;
    }
})();
A、1
B、2
C、Error (e.g. “Too much recursion”)
D、undefined
</code></pre><p><code>答案：B</code></p>
<h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><pre><code>function f() {
    return f;
}
new f() instanceof f;
A、true
B、false
</code></pre><p><code>答案：B</code></p>
<h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><pre><code>with (function(x, undefined){}) length;
A、1
B、2
C、undefined
D、Error
</code></pre><p><code>答案：B</code></p>
<p>具体答案大家可以自己运行得出，为什么会得出这样的结果，我也有一些不懂的地方，怕误人子弟，所以这里就不解答这里的问题了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于前端的几道经典面试题]]></title>
      <url>http://yoursite.com/2016/05/23/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E5%87%A0%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><br></p>
<p>前端面试的时候一般会考察你对JavaScript中函数作用域的理解，而且还会考察你对this的理解</p>
<p>年前刚刚离职了，分享下我曾经出过的一道面试题，此题是我出的一套前端面试题中的最后一题，用来考核面试者的JavaScript的综合能力，很可惜到目前为止的将近两年中，几乎没有人能够完全答对，并非多难只是因为大多面试者过于轻视他。<br><a id="more"></a><br>此题是我综合之前的开发经验以及遇到的JS各种坑汇集而成。此题涉及的知识点众多，包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等等。</p>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><pre><code>function Foo(){
    getName = function(){
        alert(1);
    }
    return this;
}
function getName(){
    alert(5);
}
var getName;
Foo.getName = function(){
    alert(2);
}
Foo.prototype.getName = function(){
    alert(3);
}
getName= function(){
    alert(4);
}

Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo.getName();// 2
new Foo().getName();// 1 || 3
new new Foo().getName();//1 || 3
</code></pre><h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>例如下边代码：</p>
<pre><code>console.log(&apos;x&apos; in window);//true
var x;
x = 0; 
</code></pre><p>代码执行时js引擎沪江声明语句提升到代码最上方，变为：</p>
<pre><code>var x;
console.log(&apos;x&apos; in window);//true
x = 0;
</code></pre><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>var getName 与 function getName 都是声明语句，区别在于 var getName 是函数表达式，而 function getName 是函数声明。关于JS中的各种函数创建方式可以看 <a href="http://www.codeceo.com/article/javascript-closure-interview.html" target="_blank" rel="external">大部分人都会做错的经典JS闭包面试题</a>这篇文章有详细说明。</p>
<p>函数表达式的最大问题就是在于js会将此代码拆分成两行代码分别执行。<br>例如：</p>
<pre><code>console.log(x);//输出：function x(){}
var x=1;
function x(){}
</code></pre><p>实际执行的代码为，先将 var x=1 拆分为 var x; 和 x = 1; 两行，再将 var x; 和 function x(){} 两行提升至最上方变成：</p>
<pre><code>var x;
x=1;
function x(){}；
console.log(x);
</code></pre><p>同理，原题中代码最终执行时的是：</p>
<pre><code>function Foo() {
    getName = function () { alert (1); };
    return this;
}
var getName;//只提升变量声明
function getName() { alert (5);}//提升函数声明，覆盖var的声明

Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
getName = function () { alert (4);};//最终的赋值再次覆盖function     getName声明

getName();//最终输出4
</code></pre><h3 id="js运算符优先级"><a href="#js运算符优先级" class="headerlink" title="js运算符优先级:"></a>js运算符优先级:</h3><p><a href="http://www.kekaoyun.com/2e1fed9cf8691bf9" target="_blank" rel="external"><img src="http://i4.buimg.com/2e1fed9cf8691bf9.png"></a></p>
<h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><p>传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。</p>
<p>而在js中构造函数可以有返回值也可以没有。</p>
<h4 id="1、没有返回值则按照其他语言一样返回实例化对象"><a href="#1、没有返回值则按照其他语言一样返回实例化对象" class="headerlink" title="1、没有返回值则按照其他语言一样返回实例化对象"></a>1、没有返回值则按照其他语言一样返回实例化对象</h4><h4 id="2、若有返回值则检查其返回值是否为引用类型。"><a href="#2、若有返回值则检查其返回值是否为引用类型。" class="headerlink" title="2、若有返回值则检查其返回值是否为引用类型。"></a>2、若有返回值则检查其返回值是否为引用类型。</h4><p>如果是非引用类型，如基本类型（string,number,boolean,null,undefined）则与无返回值相同，实际返回其实例化对象。</p>
<h4 id="3、如果返回值是引用类型，则实际返回值-为这个引用类型"><a href="#3、如果返回值是引用类型，则实际返回值-为这个引用类型" class="headerlink" title="3、如果返回值是引用类型，则实际返回值 为这个引用类型"></a>3、如果返回值是引用类型，则实际返回值 为这个引用类型</h4><p>原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。</p>
<p>之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName，找到了。</p>
<p>遂最终输出3。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js面向对象编程]]></title>
      <url>http://yoursite.com/2016/05/23/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><a href="http://www.kekaoyun.com/33d18274d72e81e7" target="_blank" rel="external"><img src="http://i4.buimg.com/33d18274d72e81e7.jpg"></a></p>
<h3 id="this的使用总结"><a href="#this的使用总结" class="headerlink" title="this的使用总结"></a>this的使用总结</h3><p>全局作用域直接调用 指向window</p>
<pre><code>var haha = “哈哈”；
console.log(this.haha);
//指向window
</code></pre><p>普通函数调用</p>
<pre><code>function fn9 () {
    this.name = &apos;123&apos;;
    this.age = &apos;30&apos;;
}
window.fn9();
//指向window

function fn9 () {
    function heihei(){
    console.log(this+&apos;heihei&apos;)
    }
    console.log(this+&apos;&apos;123);
}
window.fn9();
//指向window
</code></pre><p>作为对象属性调用 指向该对象</p>
<pre><code>varv obj = {
    name:&apos;123&apos;
    fn3 :function(){
        console.log(this.name);    
    }
}
obj.fn3();
//指向该对象
</code></pre><p>call apply的使用</p>
<pre><code>var age = 20;

var obj = {
    age:&quot;18&quot;,
    fn2:function(){
        console.log(this.age)
    }
}
obj.fn2.call(this,window);
</code></pre><h3 id="function-函数：1。返回值-2-prototype对象"><a href="#function-函数：1。返回值-2-prototype对象" class="headerlink" title="function 函数：1。返回值 2.prototype对象"></a>function 函数：1。返回值 2.prototype对象</h3><p>所有的对象都有proto属性</p>
<h3 id="后记。经典面试题"><a href="#后记。经典面试题" class="headerlink" title="后记。经典面试题"></a>后记。经典面试题</h3><pre><code>function Foo(){
getName = function(){
    alert(1);
}
return this;
}
function getName(){
    alert(5);
}
var getName;
Foo.getName = function(){
    alert(2);
}
Foo.prototype.getName = function(){
    alert(3);
}
getName= function(){
    alert(4);
}

Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo.getName();// 2
new Foo().getName();// 3
new new Foo().getName();// 3
</code></pre><p><code>hasOwnProperty检查该对象的属性是否是自身的，是的话返回true，不是的话返回false</code></p>
<p>使用示例：</p>
<pre><code>console.log(obj.hasOwnProperty(&quot;eat&quot;));
</code></pre><p><code>__proto__</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bootstrap的使用]]></title>
      <url>http://yoursite.com/2016/05/18/bootstrap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[jade-源于 Node.js的HTML模板引擎]]></title>
      <url>http://yoursite.com/2016/05/17/jade-%E6%BA%90%E4%BA%8E%20Node.js%20%E7%9A%84%20HTML%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h2 id="jade源于-Node-js-的-HTML-模板引擎"><a href="#jade源于-Node-js-的-HTML-模板引擎" class="headerlink" title="jade源于 Node.js 的 HTML 模板引擎"></a><a href="http://www.w3cplus.com/html/jade.html" target="_blank" rel="external">jade</a>源于 Node.js 的 HTML 模板引擎</h2><p>Jade 是一个高性能的模板引擎，它深受 Haml 影响，它是用 JavaScript 实现的，并且可以供 Node 使用。</p>
<a id="more"></a>
<p>特性</p>
<ul>
<li>客户端支持</li>
<li>代码高可读</li>
<li>灵活的缩进</li>
<li>块展开</li>
<li>Mixins</li>
<li>静态包含</li>
<li>属性改写</li>
<li>安全，默认代码是转义的</li>
<li>运行时和编译时上下文错误报告</li>
<li>命令行下编译jade模板</li>
<li>HTML5 模式 (使用 !!! 5 文档类型)</li>
<li>在内存中缓存(可选)</li>
<li>合并动态和静态标签类</li>
<li>可以通过 filters 修改树</li>
<li>模板继承</li>
<li>原生支持 Express JS</li>
<li>通过 each 枚举对象、数组甚至是不能枚举的对象</li>
<li>块注释</li>
<li>没有前缀的标签</li>
<li>AST Filters</li>
<li>过滤器</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.初始化项目依赖</p>
<pre><code>$ npm init 
</code></pre><p>2.安装作为项目的开发依赖：</p>
<pre><code>$ npm install gulp --save-dev

$ npm install gulp-jade --save-dev

$ npm install hulp-concat --svae-dev
</code></pre><p>3,在项目根目录中的gulpflie.js文件中配置：</p>
<pre><code>var gulp =require(&apos;gulp&apos;);
var jade = require(&apos;gulp-jade&apos;);


gulp.task(&apos;default&apos;,function () {
gulp.src(&apos;view/*.jade&apos;)
    .pipe(jade())
    .pipe(gulp.dest(&apos;desk/html/&apos;));
});
</code></pre><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>以p标签为例</p>
<pre><code>p
</code></pre><p>会转换为：</p>
<pre><code>&lt;p&gt;&lt;/p&gt;
</code></pre><p>jade能自动识别自闭和标签:</p>
<pre><code>input
</code></pre><p>会转换为：</p>
<pre><code>&lt;input/&gt;
</code></pre><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>标签中添加文本</p>
<pre><code>p 欢迎加入wandoujia-fe
</code></pre><p>会转换为：</p>
<pre><code>&lt;p&gt;欢迎加入wandoujia-fe&lt;/p&gt;
</code></pre><p>标签中嵌套标签</p>
<p>直接跟写html一样就行</p>
<pre><code>p Welcome to wandoujia fe, we want &lt;b&gt;you&lt;/b&gt;
</code></pre><p>会转换为：</p>
<pre><code>&lt;p&gt;Welcome to wandoujia fe, we want &lt;b&gt;you&lt;/b&gt;&lt;/p&gt;
</code></pre><p>标签中有大段的块内容</p>
<p>方式一：在标签后面添加 .</p>
<p>比如一段js代码，注意是script后面有一个.</p>
<pre><code>script.
    console.log(&apos;Welcome to join wandoujia-fe&apos;)
    console.log(&apos;We want you&apos;)
</code></pre><p>会转换为：</p>
<pre><code>&lt;script&gt;
    console.log(&apos;Welcome to join wandoujia-fe&apos;)
    console.log(&apos;We want you&apos;)
&lt;/script&gt;
</code></pre><p>方式二：每段前面添加|</p>
<pre><code>script
    | console.log(&apos;Welcome to join wandoujia-fe&apos;)
    | console.log(&apos;We want you&apos;)
</code></pre><p>会转换为：</p>
<pre><code>&lt;script&gt;
    console.log(&apos;Welcome to join wandoujia-fe&apos;)
    console.log(&apos;We want you&apos;)
&lt;/script&gt;
</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>以 ()来分割属性</p>
<pre><code>a(rel=&quot;nofollow&quot;, href=&quot;http://www.wandoujia.com/join#getJobInfo=1&quot;) 招聘
</code></pre><p>会转换为：</p>
<pre><code>&lt;a rel=&quot;nofollow&quot; href=&quot;http://www.wandoujia.com/join#getJobInfo=1&quot;&gt;招聘&lt;/a&gt;
</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释</p>
<pre><code>// changed by yc-team 
</code></pre><p>会转换为：</p>
<pre><code>&lt;!-- changed by yc-team --&gt;
</code></pre><p>多行注释</p>
<pre><code>body
//
  p 测试代码by yaochun
</code></pre><p>会转换为：</p>
<p><body><br><!--p 测试代码by yaochun 
--><br>    </body><br>不输出的注释</p>
<p>在单行注释上加一个短横线 -</p>
<pre><code>//- 这段注释不会输出
p 文本测试by yaochun
</code></pre><p>会转换为：</p>
<pre><code>&lt;p&gt;文本测试by yaochun&lt;/p&gt;
</code></pre><p>注意： 很多文档里面提到的条件注释已经不再支持</p>
<h3 id="doctype"><a href="#doctype" class="headerlink" title="doctype"></a>doctype</h3><p>添加一个doctype只需要doctype，然后再跟一个可选的值，默认是html</p>
<pre><code>doctype html
</code></pre><p>会转换为：</p>
<pre><code>&lt;!DOCTYPE html&gt;
</code></pre><p>注意!!!这种简写的方式已经被抛弃了~<br>可选值还有：</p>
<ul>
<li>xml</li>
<li>transitional</li>
<li>srict</li>
<li>frameset</li>
<li>1.1</li>
<li>basic</li>
<li>mobile</li>
</ul>
<h3 id="设置id或class"><a href="#设置id或class" class="headerlink" title="设置id或class"></a>设置id或class</h3><p>标签后面跟上<code>#id</code>,<code>.classname</code>，如果没有标签则使用默认标签div</p>
<pre><code>#content
p#info
a.btn
</code></pre><p>会转换为：</p>
<pre><code>&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;
&lt;p id=&quot;info&quot;&gt;&lt;/p&gt;   
&lt;a class=&quot;btn&quot;&gt;&lt;/a&gt;
1个id和多个class
</code></pre><p>连着写即可</p>
<pre><code>a#download-btn.btn.blue-btn
</code></pre><p>会转换为：</p>
<pre><code>&lt;a id=&quot;download-btn&quot; class=&quot;btn blue-btn&quot;&gt;&lt;/a&gt;
</code></pre><h2 id="更多语法部分请查看jade学习"><a href="#更多语法部分请查看jade学习" class="headerlink" title="更多语法部分请查看jade学习"></a>更多语法部分请查看<a href="http://www.w3cplus.com/html/jade.html" target="_blank" rel="external">jade学习</a></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gulp及其相关插件的安卓与使用]]></title>
      <url>http://yoursite.com/2016/05/16/gulp%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E5%8D%93%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="gulp-js-基于流的自动化构建工具"><a href="#gulp-js-基于流的自动化构建工具" class="headerlink" title="gulp.js-基于流的自动化构建工具"></a><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">gulp.js</a>-基于流的自动化构建工具</h2><a id="more"></a>
<h2 id="gulp的插件库gulp-jspluginregistry"><a href="#gulp的插件库gulp-jspluginregistry" class="headerlink" title="gulp的插件库gulp.jspluginregistry"></a>gulp的<a href="http://gulpjs.com/plugins/" target="_blank" rel="external">插件库</a>gulp.jspluginregistry</h2><h3 id="gulp插件的安装"><a href="#gulp插件的安装" class="headerlink" title="gulp插件的安装"></a>gulp插件的安装</h3><p>代码如下： </p>
<pre><code>$ sudo npm install gulp -g 
</code></pre><p>进入项目的的文件夹后初始化开发依赖的的josn文件：</p>
<pre><code>$ npm int
</code></pre><p>然后设置相关配置后进行一些常用插件的安装，如jsmin，cssmin，jsconcat：</p>
<pre><code>$ npm install gulp-jsmin --save-dev
</code></pre><p>其他插件的安装和上边一样；</p>
<h3 id="配置gulp任务和参数"><a href="#配置gulp任务和参数" class="headerlink" title="配置gulp任务和参数"></a>配置gulp任务和参数</h3><p>在目标文件夹中，创建一个叫gulpfile.js的文件</p>
<p>打开文件编辑，通过gulp.task()来建立任务进程，</p>
<p>其中三个参数分别是<code>任务名</code>,<code>任务依赖</code>，<code>回调</code>;</p>
<pre><code>var gulp =require(&apos;gulp&apos;);
var jsmin = require(&apos;gulp-jsmin&apos;);
var cssmin    = require(&apos;gulp-cssmin&apos;);
var concat = require(&apos;gulp-concat&apos;);

gulp.task(&apos;default&apos;,function () {
console.log(&apos;hahahha&apos;);
})
gulp.task(&apos;jsmin&apos;,function(){
gulp.src(&apos;js/index.js&apos;)
.pipe(jsmin())
.pipe(gulp.dest(&apos;desk/index.js&apos;))
})
</code></pre><p>gulp.src() </p>
<pre><code>    目标文件
gulp.dest
    目标输出
pipe()
    管道，上面的输出就是下面的输入
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实现框内的图片居中（商品图片常用）]]></title>
      <url>http://yoursite.com/2016/05/13/%E5%AE%9E%E7%8E%B0%E6%A1%86%E5%86%85%E7%9A%84%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%EF%BC%88%E5%95%86%E5%93%81%E5%9B%BE%E7%89%87%E5%B8%B8%E7%94%A8%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在一些场景中，我们经常要用到对一些未知尺寸的照片进行居中显示，例如购物网站的商品详情图片展示中，这时候要求我们对图片进行处理以适应这个展示窗口；<br><a id="more"></a></p>
<h2 id="margin值实现"><a href="#margin值实现" class="headerlink" title="margin值实现"></a>margin值实现</h2><p>我们采用了将图片转化为块标签的方式来用margin值来实现<br>具体代码下边展示:</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
    *{
        margin: 0;
        padding: 0;
     }
    .box{
        border: 1px solid black;
        height: 300px;
        width: 400px;
        }

    img{
        /*margin: 0 auto;*/
        display: block;
        margin: 0 auto;
        height: 100%;
        width: auto;
        }
&lt;/style&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[三分栏的自适应设计]]></title>
      <url>http://yoursite.com/2016/05/12/%E4%B8%89%E5%88%86%E6%A0%8F%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>我们在编辑布局的时候去实现三栏布局，左右两侧随着屏幕的宽度的变化自适应变化，中间的一栏固定宽度不变，我们采用了伪元素的方式来实现。分别采用::befroe和::after伪元素来实现左右两栏的填充，<br><a id="more"></a></p>
<h2 id="用伪元素实现三栏的流式布局"><a href="#用伪元素实现三栏的流式布局" class="headerlink" title="用伪元素实现三栏的流式布局"></a>用伪元素实现三栏的流式布局</h2><p>具体示例代码如下所示：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Document&lt;/title&gt;
&lt;style&gt;
*{
    margin: 0;padding: 0
}
ul{
    list-style: none;
}
.head{
    position: fixed;top: 0;width: 100%
}
.nav{
width: 875px;height: 75px;position: relative;
margin: 0 auto;
}
ul{
background: darkgray;width: 800px;
float: left;height: 75px
}
img{
    float: left;
}
.nav::before{
    content: &apos;&apos;;
    width: 100%;
    height: 75px;
    position: absolute;
    left: -100%;background: purple;
    top: 0
}
.nav::after{
    content: &apos;&apos;;
    width: 100%;
    position: absolute;
    right: -100%;background-color:burlywood;
    top: 0;
    height: 75px;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;head&quot;&gt;
    &lt;div class=&quot;nav&quot;&gt;
        &lt;div&gt;
            &lt;img src=&quot;../1.png&quot; alt=&quot;&quot;&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;/li&gt;
                &lt;li&gt;&lt;/li&gt;
                &lt;li&gt;&lt;/li&gt;
                &lt;li&gt;&lt;/li&gt;
                &lt;li&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[标签语义化]]></title>
      <url>http://yoursite.com/2016/05/12/%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[伪元素的使用]]></title>
      <url>http://yoursite.com/2016/05/12/%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>  伪元素是创造关于文档语言能够指定的文档树之外的抽象。  例如文档语言不能提供访问元素内容第一字或者第一行的机制。伪元素允许设计师引用它们，否则这是难以办到的。伪元素还提供样式设计师给在源文档中不存在的内容分配样式（例如：:before和:after能够访问产生的内容）。<br><a id="more"></a></p>
<h2 id="常用的伪元素的种类"><a href="#常用的伪元素的种类" class="headerlink" title="常用的伪元素的种类"></a>常用的伪元素的种类</h2><ul>
<li>::before  </li>
<li>:: after</li>
<li>::first-line</li>
<li>::first-letter</li>
<li>::selector</li>
</ul>
<h2 id="伪元素的语法"><a href="#伪元素的语法" class="headerlink" title="伪元素的语法"></a>伪元素的语法</h2><pre><code>p:first-line  
  {
  color:#ff0000;  
  font-variant:small-caps;  
  }
</code></pre><h2 id="伪元素的定义"><a href="#伪元素的定义" class="headerlink" title="伪元素的定义"></a>伪元素的定义</h2><p><strong>注释：</strong>“W3C” 列指示出该属性在哪个 CSS 版本中定义（CSS1 还是 CSS2）。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>::first-letter</td>
<td>向文本的第一个字母添加特殊样式。</td>
<td>1</td>
</tr>
<tr>
<td>::first-line</td>
<td>向文本的首行添加特殊样式。</td>
<td>1</td>
</tr>
<tr>
<td>::before</td>
<td>在元素之前添加内容</td>
<td>2</td>
</tr>
<tr>
<td>::after</td>
<td>在元素之后添加内容</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><strong>注释</strong></p>
<p>“first-line”和”first-letter”可以用于得到属性</p>
<ul>
<li>font</li>
<li>color</li>
<li>background</li>
<li>margin</li>
<li>padding</li>
<li>border</li>
<li>text-decoration</li>
<li>vertical-align (仅当 float 为 none 时)</li>
<li>text-transform</li>
<li>line-height</li>
<li>float</li>
<li>clear</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于前端的思考与感悟]]></title>
      <url>http://yoursite.com/2016/05/12/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%82%9F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章应该道出很多人的心声了。不急慢慢看，会扣住你的心。5月2号了，5月20号还会远吗？今天我们就来看看由@看不懂未来对前端的感悟与思考。<br><a id="more"></a><br>正文从这开始～</p>
<p>万事开头难。<br>当我想要认真写一篇文章向大家分享我对前端的认识与感悟的时候，突然就深刻的体会到了这句话确实太有道理了。</p>
<p>最近几年对于web前端的传闻很多，比如人才稀缺，简单易学，待遇丰厚，整体势头发展良好等等。遇到过一个不太熟搞后台开发的同事跑来问我学习前端需要掌握哪些内容，也听说过一个搞IOS开发准备自学前端半个月然后要去找前端工作，也曾看到过有人对前端市场人才的稀缺这样吹捧过：<br>现在，几乎整个互联网行业都缺前端工程师，不仅在刚起步的创业公司，对上市公司乃至巨头这个问题也一样存在。没错，优秀的前端工程师简直比大熊猫还稀少。<br>… …</p>
<p>不仅在国内的互联网行业，在国外，前端工程师一样是需求旺盛、供不应求的香饽饽。</p>
<p>对于这样的吹捧，不反对也不支持。因为由于每个人的位置，经历的不同，对事总会有不同层面的理解。而作为一个从成都的菜鸟，蜕变成一名北京的菜鸟，也来谈谈自己对于前端的理解。</p>
<h2 id="一、地域差异"><a href="#一、地域差异" class="headerlink" title="一、地域差异"></a>一、地域差异</h2><p>在成都的大部分公司，有一种专门负责切图排版的网页工程师。他们需要懂一些PS，然后会使用HTML与CSS排版。而这类人往往是刚参加工作不久的毕业生，响应式布局对他们来说是一种高大上的技能。很荣幸，我也曾经是他们的一员，也正因为如此，我掌握着熟练的切图技巧，而这个层次，可能就是外人认为的入门容易吧，然而实际上还差很远很远。</p>
<p>另外一种，就是比较厉害一点的程序员。他们会js+一门后端语言，比如php，jsp。但是他们会会更加偏向后端一点，他们将html,css,js当成一种很基本的东西，更多的逻辑都使用后端语言来处理，并不会那么清晰的将html页面与后端语言分离开来。所以我们常常会看到有的页面以.php，.jsp结尾。</p>
<p>来了北京之后，才算是见识了真正的web前端。以至于常常会有一种恨自己为什么不早一点来的感觉，恍如隔世。随着学习的慢慢提升，会感觉到北京的前端更加具有明确的方向。</p>
<p>我们会真正的注重用户体验，所以每个页面都会响应式布局，从PC端适配到最小320px宽度的移动端，更加注重html5/css3的相关知识的运用，也会为了用户体验做很多功能之外的更加合理的处理。会真的很认真的考虑面试中常常会问的如何优化前端性能。因此我们使用gulp+require来构建前端代码，压缩，打包，上传cdn。</p>
<p>总的来说，在北京，前端更加专业与明确一点，发展更加好一点。</p>
<h2 id="二、兴趣是否重要？"><a href="#二、兴趣是否重要？" class="headerlink" title="二、兴趣是否重要？"></a>二、兴趣是否重要？</h2><p>我曾经很认真的思考过这个问题，很多前辈大神告诉我，“兴趣很重要。”</p>
<p>可是我经过仔细分析自身的情况之后，却得出了一个相反的结论。</p>
<p>因为我并没有发现什么东西是我感兴趣、并且能让我能够混口饭吃的。然后现在我也觉得只要我能够这样慢慢努力下去，在前端这个行业里，还是能够拥有一席之地。现实一点来说，只要你能够进下心来不排斥它，你就可以选择它。毕竟人都是要吃饭，要养活自己的，我想大多数人都是没办法指着自己的兴趣过活的。</p>
<p>《一万小时天才理论》告诉我们，在某一个方向专注一万小时，你就能够成为这个方向的专家。我认为，这个道理，在前端也同样适用，专注，比兴趣更加重要。</p>
<h2 id="三、什么心态会影响自己的进步？"><a href="#三、什么心态会影响自己的进步？" class="headerlink" title="三、什么心态会影响自己的进步？"></a>三、什么心态会影响自己的进步？</h2><p>不坚定。<br>至少我现在可以肯定的是，前端方向，并不是一个糟糕的选择。在最初的时候，时常会在UI设计与前端之间摇摆不定。我认为我对UI设计更加感兴趣一点。特别是参与了电信一个视频播放app的设计之后，更是认为自己未来是有机会成为一名优秀的UI设计师。但是我另外又觉得自己在前端方向会更加快一点提升自己。于是在很长一段时间里就纠结在这个问题上摇摆不定，停滞不前。其实不管坚定的选择哪一个方向，在目前的互联网行业里，都是很热门的选择，都有出头之日。而最大的错误就在于，犹豫不决。</p>
<p>浮躁。<br>如果我最终没能成为一名优秀的前端工程师，那么最大的原因肯定就是心态的浮躁。</p>
<p>谁都想要在短期内成为一名学识渊博，经验丰富，德高望重的前端工程师。我也想，这是很难避免的一个心态问题，别人高额的薪水与自己的困境总是那么轻易的扰乱心神。所以一个月从入门到精通，3个月从入门到精通之类的宣传标语，都是非常受欢迎。然而事实上，这并不可能。打着这些宣传标语的培训机构，最多只能带你入门。甚至很有可能一位在前端行业沉浮好几年的老同学都不敢说自己已经在这个行业算得上优秀了。并不是说几年的时间没办法变得优秀，而是能够静下心来潜心修炼的人确实凤毛麟角。所以其实实际情况是慢慢来，才最快</p>
<p>毕业几年，感觉自己前进道路上最大的阻碍就是这两个心态问题。这也正是我开公众号的初衷所在，我希望能够静下心来，将自己学到的东西整理出来，分享给大家，一来慢慢竖立自己的个人品牌，让别人能够更加简单直接的了解自己，二来也锻炼自己的心态。在这里也谢谢大家的关注与支持。</p>
<h2 id="四、-如何应对新技术层出不穷的现状"><a href="#四、-如何应对新技术层出不穷的现状" class="headerlink" title="四、 如何应对新技术层出不穷的现状"></a>四、 如何应对新技术层出不穷的现状</h2><p>很多时候我都会觉得前端对于新人来说其实挺过分的。</p>
<p>想要学习一门ui框架，有什么easyui，bootstrap，Foundation等等。想要搞一个自己的静态博客，有什么wordpress，jekyll，hexo等等</p>
<p>想要学构建工具，有什么grunt，gulp，webpack等等</p>
<p>还有好多传说中都很厉害的库，jQuery，angular，vue，react等等</p>
<p>真的眼花缭乱，刚开始怎么分得清谁比谁好啊。一不小心就走一大堆的弯路。<br>所以这个时候我们就必须明白一个道理。基础的重要性在于，他能够提高我们的学习能力。</p>
<p>bootstrap，angularjs最初于我如传说中的存在，高不可攀。而且很多公司招人都希望员工能够掌握这些技术。所以在基础很薄弱的时候就开始尝试去学习。很显然，效果是几乎没有的。反而会减少我对于前端的自信，会很容易产生动摇，觉得自己不适合。</p>
<p>可是随着基础的慢慢提升，我发现要掌握bootstrap与angularjs似乎也没有那么难。我甚至能够看着文档就有模有样的将这些技术运用起来。这对于以前的我来说，简直就是不可思议。</p>
<p>因此，从以前的高不可攀，到现在的触手可及，让我明白了基础的重要性。<br>而对于最近非常火的react，webpack等，掌握起来也没有当初那种无法触及的感觉。这些技术之所以能火，就说明能够学会的人很多，他并不存在特别难以掌握的瓶颈。如果你的基础够牢靠，你就是这些技术的弄潮儿。</p>
<h2 id="五、前端并没有那么简单"><a href="#五、前端并没有那么简单" class="headerlink" title="五、前端并没有那么简单"></a>五、前端并没有那么简单</h2><p>前端不简单的地方，并不在于知识点的掌握，技术的实现，而在于寻找更优解。即使是最简单的页面布局，也存在层出不穷的优秀解决方案，比如在大学的时候，常用table元素来实现几乎所有的页面布局，到现在理解文档流，会运用浮动，各种盒模型，BFC等来实现布局这中间的差距对于一个新人来说是非常巨大的。</p>
<p>从最初的写一大堆js代码，实现一个页面的小功能，到后来发现有的人只需要用几行代码配合html/css就可以控制整个页面的所有动画，这中间的差距，也是非常巨大的。所以前端并不是外界认为的那么简单，甚至并不比掌握好一门后端程序语言那么容易。所以我们要保持敬畏之心。</p>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><p>学习方法<br>在我这个阶段的认识来看，我认为学习最靠谱的方法就是积累。有一个很普遍的假象是，互联网时代似乎获取知识越来越容易，很多人都在担忧所谓的信息过剩的问题。然而实际情况却是，我们更加难以捕捉到对我们来说真正有用的信息。而前端的知识相对而言更加零散与碎片化，并且越来越多样化，所以知识的积累则是一个非常重要的过程。</p>
<p>英语很重要<br>英语很重要的原因是因为国外的技术比我们发达，我们常常需要阅读国外的文章来提升自己，也常常需要在google搜索上找到自己问题的答案</p>
<p>总的来说，在前端的道路上，遇到过动摇，困惑，迷茫。也因为浮躁的心态停滞不前。好在都一步一步的走了过来。并且可以很把握的告诉自己，这个方向，不会亏待我的付出与努力。</p>
<p>花了很多时间，终于把这篇文章写完了，泪奔！写文章对于一个程序员来说真的是超级大的挑战。感悟就是万事开头难，中间难，结尾也难。</p>
<p>后语<br>看完这篇，你的关键词是什么呢？你是属于哪一种呢？</p>
<p>关于本文<br>作者：@<a href="https://segmentfault.com/a/1190000004976918" target="_blank" rel="external">看不懂未来</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git仓库的搭建]]></title>
      <url>http://yoursite.com/2016/05/12/git%E4%BB%93%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>Git是一个分布式的版本控制系统，最初由Linus Torvalds编写，用作Linux内核代码的管理。在推出后，Git在其它项目中也取得了很大成功，尤其是在Ruby社区中。目前，包括Rubinius、Merb和Bitcoin在内的很多知名项目都使用了Git。Git同样可以被诸如Capistrano和Vlad the Deployer这样的部署工具所使用。<br><a id="more"></a></p>
<p></p><h2>git仓库的搭建</h2> <!--more--><br> <h3>创建<a href="https://github.com/" target="_blank" rel="external">github</a>账号</h3>  <img src="http://i4.buimg.com/ccf9a78c639294ce.jpg" alt="zhuce"><p></p>
<p></p><h3>新建一个repositories仓库</h3>  <img src="http://i4.buimg.com/0ddd0201c18ef377.jpg"><p></p>
<p></p><h3>设置ssh-keygen</h3><p></p>
<p></p><h3>vim获取Keygen</h3><code>$ vim ~/.ssh/id_rsa.pub</code><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Phane主题的使用]]></title>
      <url>http://yoursite.com/2016/05/11/Phane%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="主题概括"><a href="#主题概括" class="headerlink" title="主题概括"></a>主题概括</h2><p>acman是一款为Hexo打造的一款扁平化，有着响应式设计的主题。本站正是为该主题设计的演示站点，同时你也可以访问<a href="http://changxinle.github.io/" target="_blank" rel="external">我的博客</a>查看效果。主题源码托管在Github上，欢迎Fork。遇到任何问题或意见请发表issue。<br><a id="more"></a></p>
<h2 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/A-limon/pacman.git themes/pacman</span><br><span class="line">```  </span><br><span class="line">&lt;br&gt;</span><br><span class="line">Pacman需要安装Hexo 2.4.5 或以上版本 请先升级您的Hexo程序，再启用此主题。</span><br><span class="line"></span><br><span class="line">### 启用</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">修改你的博客根目录下的`config.yml`配置文件中的theme属性，将其设置为`pacman`。同时请设置`stylus`属性中的`compress`值为`true`。</span><br><span class="line"></span><br><span class="line">### 更新</span><br><span class="line">```  cd themes/pacman      </span><br><span class="line">	git pull</span><br></pre></td></tr></table></figure>
<h2 id="配置指南"><a href="#配置指南" class="headerlink" title="配置指南"></a>配置指南</h2><p>Pacman主题提供了丰富的配置属性，配置文件<code>_config.yml</code>位于主题根目录下。配置文件中已经包含了详细的英文注释，所以下面就用中文进行说明。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>##### Menu
menu:
  主页: /
  存档: /archives
   # 分类: /tags (or categories)

## you can create `tags` and `categories` folders in `../source`.
## And create a `index.md` file in each of them.
## set `front-matter`as
# layout: tags (or categories)
# title: tags (or categories)
## ---

#### Widgets
widgets: 
- category
- tag
- rss
## provide six widgets:category,tag,rss,archive,tagcloud,links.
## modify links in `/layout/_widget/links.ejs`.

#### RSS
rss: ## RSS address.

#### Image
imglogo:
  enable: true             ## display image logo true/    false.
  src: img/logo.svg        ## `.svg` and `.png` are recommended,please put image into the theme folder `/pacman/source/img`.
favicon: img/favicon.ico   ## size:32px*32px,`.ico` is recommended,please put image into the theme folder `/pacman/source/img`.     
apple_icon: img/pacman.jpg ## size:114px*114px,please put image into the theme folder `/pacman/source/img`.

#### Author Avatar Picture
author_img_enable: true ## display author avatar picture
dataURI: false
## if the picture&apos;s format is dataURI please set the value to true,otherwise set the value to false.
## convert an image into base 64 data URIs http://websemantics.co.uk/online_tools/image_to_data_uri_convertor/ .
author_img_data: &apos;&apos;
## paste the dataURI in ONE LINE and included it by &apos;&apos;.
author_img: img/author.jpg ## size:220px*220px.
## if the picture&apos;s format is `.png` or `.jpg`  instead of dataURI,you should set the `dataURI` value to false.

#### Font
ShowCustomFont: true  
## you can change custom font in `variable.styl` and `font.styl` which in the theme folder `/pacman/source/css`.

#### Toc
toc:
article: true   ## show contents in article.
aside: true     ## show contents in aside.
## you can set both of the value to true of neither of them.
## if you don&apos;t want display contents in a specified post,you can modify `front-matter` and add `toc: false`.

#### Fancybox
fancybox: false 
## if you use gallery post or want use fancybox please set the value to true.
## if you want use fancybox in ANY post please copy the file `fancybox.js`.
## in theme folder `/pacman/scripts` to your hexo blog folder `../scritps`.

#### Author information
author:
  google_plus:    ## eg:116338260303228776998 for https://plus.google.com/u/0/116338260303228776998
  intro_line1: &quot;&quot; ## eg: &quot;Hello ,I&apos;m Larry Page in Google.&quot;
  intro_line2: &quot;&quot; ## eg: &quot;This is my blog,believe it or not.&quot;
  weibo:      ## e.g. 436062867 for http://weibo.com/436062867
  twitter:    ## e.g. yangjiansky for https://twitter.com/yangjiansky
  github:     ## e.g. A-limon for https://github.com/A-limon
facebook:   ## e.g. yangjian for https://favebook.com/yangjian
tsina:      ## e.g. 1664838973  Your weibo ID,It will be used in share button.
linkedin:   ## e.g. in/jeffweiner08 for https://www.linkedin.com/in/jeffweiner08

#### Comment
duoshuo: 
enable: true  ## duoshuo.com
short_name:    ## duoshuo short name.

#### Share button
jiathis:
  enable: false ## if you use jiathis as your share tool,the built-in share tool won&apos;t be display.
id:    ## e.g. 1501277 your jiathis ID. 
tsina: ## e.g. 1664838973 Your weibo id,It will be used in share button.

#### Analytics
google_analytics:
  enable: false
  id:   ## e.g. UA-1766729-8 your google analytics ID.
  site: ## e.g. yangjian.me your google analytics site or set the value as auto.
## You MUST upgrade to Universal Analytics first!
## https://developers.google.com/analytics/devguides/collection/upgrade/?hl=zh_CN

#### Custom Search
google_cse: 
enable: false
cx:  ## e.g. 000561263943549425496:mrzrm0gr4kg your Custom Search ID
## https://www.google.com/cse/ 
## To enable the custom search You must create a &quot;search&quot; folder in &apos;/source&apos; and a &quot;index.md&quot; file
## set the &apos;front-matter&apos; as
## layout: search 
## title: search
## ---
</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>menu 默认没有启用 <code>/tags</code> 和 <code>/categories</code> 页面，如果需要启用请在博客目录下的<code>source</code>文件夹中分别建立<code>tags</code>和 <code>categories</code>文件夹每个文件夹中分别包含一个<code>index.md</code>文件。内容为：</p>
<pre><code>layout: tags (或categories)
title: tags (或categories)
---
</code></pre></li>
</ul>
<p>因为主题中已经内置了这两个页面的模板，所以他们会被正确的解析出来。</p>
<ul>
<li>widgets: 提供了6种小工具。</li>
<li>rss: 请填写你博客的RSS地址。</li>
<li>imglogo: 建议启用图片logo，格式建议为.svg或.png格式。同时建议提供配套的favicon以及在苹果设备上的图标（背景不要透明）。</li>
<li>author_img_enable: 是否显示底部的作者头像。主题支持头像使用dataURI格式，若使用请修改dataURI的值为true并在下面的 -author_img_data后填上图片的值，确保它是一行而且被引号包住如果还是想用传统的jpg格式那么就把图片路径放在author_img后，同时把dataURI设置成false。</li>
<li>ShowCustomFont: 启用自定义字体，如果你有一定前端基础可以修改font.styl替换为你喜欢的字体。</li>
<li>toc: 是否启用在文章中或侧边栏中的目录功能。二者可以都为true或都为false。同时，如果你希望在特定的某一篇文章中关闭目录功能你可以在文章文件开头中的front-matter中加上一行toc: false。<br>fancybox: 默认关闭，如果你使用Hexo经常发表Gallery类型的文章，那么请设置为true（同时需要复制fancybox.js到你的博客目录下scripts文件夹中）。ps: 我很佩服用Hexo发表相册的文艺青年。</li>
<li>author: 作者信息，建议尽量填写完整。其中tsina是你的新浪微博ID，不同于用户名或微博主页地址。启用这个属性后，其他用户在微博上分享你文章的同时会自动@你。</li>
<li>duoshuo: 多说评论系统。在大陆地区更好用的评论系统，如果你想更换为disqus请参考默认主题后自行修改。</li>
<li>jiathis: 加网分享系统。默认关闭，因为主题已经内置了原生的分享功能。<br>google_analytics: Google Analytics追踪代码。请注意：*Google Analytics已经升级到了Universal Analytics。请先前往后台升级你的Google Analytics版本后再启用追踪代码 更多信息请点击这里了解。</li>
<li>google_cse: Google自定义搜索。如果开启自定义搜索需要先登录Google CSE，配置好你的站点，并获得此自定义搜索的ID。此外你需要在博客目录下的source文件夹中建立search文件夹并包含一个index.md文件。内容为：  <pre><code><figure class="highlight plain"><figcaption><span>search</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```  </span><br><span class="line">```title: search  </span><br><span class="line">```  </span><br><span class="line">```---</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
