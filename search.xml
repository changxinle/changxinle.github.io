<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[学习提高你CSS技术的法则]]></title>
      <url>http://yoursite.com/2016/07/23/%E5%AD%A6%E4%B9%A0%E6%8F%90%E9%AB%98%E4%BD%A0CSS%E6%8A%80%E6%9C%AF%E7%9A%84%E6%B3%95%E5%88%99/</url>
      <content type="html"><![CDATA[<p>在今天的文章中，我将要聊聊我在一年半的实践中，总结出来的css经验。</p>
<p>首先让我提醒你，css是极其简单的一门语言，简单到可以用三个词概括：选择器，属性以及属性的值。这也是一些人不喜欢css的原因：他们觉得写css像孩子玩乐高玩具一样简单。</p>
<p>是这样的。。如果你给一个9岁的孩子介绍css的基本原理，他就会搭建一个网站。不过这个网站不会很复杂，也就是一些包含头部，链接，内容图片的页面而已。</p>
<p>事实上，css是一门简单的语言，并不意味着每个人的水平一样。有些人写起css来就跟个大猩猩在玩棍子，有些人可以掌握css,而有些人可以使用魔法般的使用css。<br><a id="more"></a></p>
<p>不管怎样，我还是要给你分享一些我这几个月来理解的东西，这并不是一些代码片段或者是css小技巧，而更像是一些通用的规则或者是最佳实践之类的东西，如下：</p>
<ul>
<li>不要让你的代码脱离你的掌控，尽量简洁  </li>
<li>掌握基础，学习CSS技巧  </li>
<li>保持代码的可复用性  </li>
<li>面向对象的css</li>
<li>Css3 了解他能做的以及你可以使用的部分</li>
<li>渐进增强与优雅降级</li>
<li>Css预处理工具</li>
<li>与时俱进</li>
<li>取长补短</li>
<li>熟能生巧<br>你想说什么呢？你准备好了？那我们继续往下吧。</li>
</ul>
<h2 id="1-不要让你的代码脱离你的掌控，尽量简洁"><a href="#1-不要让你的代码脱离你的掌控，尽量简洁" class="headerlink" title="1.不要让你的代码脱离你的掌控，尽量简洁"></a>1.不要让你的代码脱离你的掌控，尽量简洁</h2><p>别让你的代码脱离你的掌控</p>
<p>这是编程的一种通用建议，不仅仅适合css. 当你开始写代码的时候，先思考，思考以下几个问题：</p>
<p> 我怎样实现？</p>
<p> 有其他方法实现么？</p>
<p> 怎样优化（简洁，可维护，等等）？<br>急于编码会浪费时间，你有可能花了一个小时也没实现，不得不从头再来，这不应该发生。</p>
<p>如果你花了好几个小时写一个css幻灯片，最终没办法用了个js幻灯片插件或者别的，这是很蛋疼的，并不是说你没成功，而是无谓的浪费了很多时间。如果项目有deadline的话，你就要悲剧了。</p>
<p>保持他的简单性  </p>
<p>Css很简单，但如果你想，同样可以变得很复杂。在很多场景里，最简单的即是最好的。当你要实现什么效果的时候，问问自己：还有更简单的方法实现么？ 答案经常是肯定的。</p>
<p>举个例子，简单水平导航栏，你可以有多种方法实现：</p>
<p> 列表元素浮动；<br> 改变列表元素display属性为inline；<br> 改变列表元素display属性为inline-block。<br>最简单的-设置display:inline，不需要清除浮动，不需要清除inline-block造成的空白，只需要一些padding即可，结束。</p>
<h2 id="2-掌握基础，学习CSS技巧"><a href="#2-掌握基础，学习CSS技巧" class="headerlink" title="2. 掌握基础，学习CSS技巧"></a>2. 掌握基础，学习CSS技巧</h2><p>不仅是掌握css,掌握任何东西都要从基础做起。一个对最基本的东西都理解不透彻的人是不可能成为大师的。</p>
<h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3><p>什么是css基础呢？你可能会听到不同的声音，这也是一种无法用言语表达的东西。但我认为，css的基础是以下两部分：</p>
<h3 id="盒模型："><a href="#盒模型：" class="headerlink" title="盒模型："></a>盒模型：</h3><p>每个元素在css中都是一个盒子模型(块级或者内联)，包含宽高及各种padding margin border.这是最重要的,详细可以阅读这里。</p>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重:"></a>权重:</h3><p>了解哪个属性权重最高，在调试css中非常重要。更多相关信息可以阅读Assigning property values, Cascading, and Inheritance一文。</p>
<h3 id="CSS技巧"><a href="#CSS技巧" class="headerlink" title="CSS技巧"></a>CSS技巧</h3><p>当你了解了以上原理，才算踏上了康庄大道。那么现在你可能会处理一些特殊情况，下面展示了一些：</p>
<p>忘了在父元素设置position</p>
<pre><code>.child {
position: absolute;
 top: 0;
 left: 0;
}

/* 这是忘了的*/
/*
.parent {
  position: relative; // Or anything else than static
}
*/
</code></pre><p>这时候你会想：坑爹啊，怎么东西跑到页面左上角了？？？你忘了给父元素设置 position:absolute或relative了。。</p>
<p>添加下下层技巧</p>
<pre><code>.parent {
  z-index: 1;
  opacity: 0.5;
  transform: rotate(5deg);
}

.child {
  z-index: -1;
}
</code></pre><p>每个搞前端的都被层叠上下文折磨过。这个例子告诉我们，你不能对一个已经触发层叠上下文的元素（可能是z-index,transform或者是透明度）的子元素来应用z-index属性。 这没有变通方案，一旦你遇到过，绝对会记忆犹新。。</p>
<p>忘了清除浮动的技巧</p>
<p>你的布局乱套了，容器乱飞。你泪流满面：这是肿摸了。。请检查下浮动，可能忘了清除浮动了。</p>
<p>记住，一个容器如果仅仅包含浮动元素，他会塌陷，除非你清除浮动或者设置height或者overflow属性。</p>
<p>这种例子比比皆是，如果继续写那就没完没了了，这不是我这篇文章的目的。</p>
<p>我只是想指出 每天，人们都会不断的发现，css有很多的特性跟特殊情况。 你可能这一次踩个坑，下次就知道怎么对付了。</p>
<h2 id="3-保持代码的可复用性"><a href="#3-保持代码的可复用性" class="headerlink" title="3. 保持代码的可复用性"></a>3. 保持代码的可复用性</h2><p>Dry代表 不要重复自己。这并不是css特有的，这适合任何语言。</p>
<p>它的核心思想是，能重用的代码就不要写第n遍。在别的语言意味着封装成function,在css里，常常代表你需要利用一个可复用的类来代替重复应用的一个属性。这将在后面的面向对象css中进一步讲解。其实对于重构来说这是很简单的，我来解释一下：</p>
<p>当你在你的样式表里发现一段代码多次使用的时候，你需要重构一下，最终变成只出现一次（可复用）。例子：</p>
<pre><code>.navigation li {
  color: #333;
}

.navigation li a {
  color: #333;
}

/* Refactoring */

.navigation li,
.navigation li a {
  color: #333;
}
</code></pre><p>明白么？你肯定会纳闷，这俩有啥区别啊？有两点需要考虑： 性能跟可维护性。</p>
<p>关于性能： 更少的行数意味着浏览器解析css会更快。按照下面这样写，浏览器会同时给两个选择器应用颜色，而不会解析两次。</p>
<p>关于可维护性，如果你需要修改类似的颜色，这样只需要修改一行，这里可能仅仅是两行，如果50行，100行呢。</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p> DRY CSS, don’t repeat your CSS<br> DRY CSS: a don’t-repeat-yourself methodology for creating efficient, unified and scalable style sheets  </p>
<h2 id="4-面向对象的css"><a href="#4-面向对象的css" class="headerlink" title="4. 面向对象的css"></a>4. 面向对象的css</h2><p>这是什么东东？</p>
<p>Oocss意思是面向对象的css，经常在其他面向对象的语言中出现这个名词。意思是利用一个“对象”，通常为一个类的实例（包含一些属性和方法）。你可能会问：这跟css有啥关系啊。</p>
<p>首先我要说明，oocss更像一个概念，css是不能真的“面向对象编程”的，因为没有命名空间，函数，方法，类，条件语句等。因此你要是谈oocss可能会被人嘲讽。</p>
<p>事实上我也是这么认为的，但我们可以利用这样的思想来促进css的书写，让网站性能提升，提高可维护性。</p>
<p>我们应该怎么做？</p>
<p>很简单，使用类名，各种类名。可以把你的网站想象成一个带有很多“方法”跟“组件”的地方，尝试找出这些重复的部分，把他们作为“对象”(类名)，从而重用。</p>
<p>为了让你的对象划分的更精确，有两点需要注意：</p>
<p> 分离结构与表现<br> 分离容器与内容<br>单独的结构和样式   </p>
<p>分离结构与表现是很重要的，这样你就可以单独操作负责显示的部分，让这部分在网站中多次出现，并且作用于不同的元素上。看看下面的代码，它可以作用到一个盒子，一个图片，或者一个按钮上：</p>
<p>#my-button,<br>.my-box<br>.my-box img {<br>  border: 1px solid #444;<br>  border-radius: 5px;<br>  box-shadow: 0 0 5px rgba(0,0,0,0.1);<br>}<br>另外我们可以用一个叫做.skin的类名代替，然后应用到所要使用的元素上</p>
<p>.skin {<br>  border: 1px solid #444;<br>  border-radius: 5px;<br>  box-shadow: 0 0 5px rgba(0,0,0,0.1);<br>}<br>这样使用，会让css样式表更加容易让人理解，更容易维护，解析更快。</p>
<p>单独的容器（结构）和内容</p>
<p>我认为这是oocss最重要的一点：每种组件拥有独立的代码，而不是在你某次写页面时配合页面的特定部分来定义。在你的站点中，类似的组件应该重用，就像下面代码一样：</p>
<pre><code>#main h2 {
  color: #343434;
  font-size: 25px;
  line-height: 20px;
  border-bottom: 1px solid rgba(0,0,0,0.2);
  box-shadow: 0 1px rgba(255,255,255,0.4);
}
</code></pre><p>这时候不管是我从页面底部再次使用h2，或者我用同样的思想使用h3，都可以类似上面所写的，创建一个类，并给类设置样式，而不是给元素单独设置样式。</p>
<p>关于从不使用ID的一说？</p>
<p>当Nicole Sullivan提出oocss的概念时，最热烈的讨论是“绝对不使用id选择器么？” Nicholas C. Zakas 与 Nicole Sullivan在他们的csslint(css质量检查工具)中特别反对对id选择器的使用。</p>
<p>为了理解nicole的观点，我们必须认识到id选择器因为高权重会在使用中出现一些问题。如下代码（代码来自于这里）：</p>
<pre><code>&lt;!-- HTML --&gt;
&lt;div id=&quot;header&quot;&gt;
&lt;p&gt;
&lt;a href=&quot;#&quot;&gt;Foo&lt;/a&gt;
&lt;a href=&quot;#&quot;&gt;Bar&lt;/a&gt;
&lt;/p&gt;
&lt;div class=&quot;tweet&quot;&gt;
&lt;a href=&quot;#&quot;&gt;Follow me on twitter&lt;/a&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;tweet&quot;&gt;
    &lt;a href=&quot;#&quot;&gt;Follow me on twitter&lt;/a&gt;
&lt;/div&gt;
/* CSS */
#header a { color: #f90;  }
.tweet     a { color: #000; }
</code></pre><p>如果让第一个twitter的链接变黑，你有两种选择：给一个id,或者利用！important选择器来机枪打蚊子。如果header是一个类名，就不会有这种问题了。</p>
<p>这也是Nicole Sullivan为什么讲“no ID”的原因。</p>
<p>我引用 harry roberts对此话题的一个讨论来作为这节结束</p>
<p>[…] I have decided that a blanket ban is sensible. Save yourself many potential headaches and never use IDs in your CSS files.<br>当然原则上id是可以使用的，而且很易生效</p>
<p>我对OOCSS的理解</p>
<p>事实上我并不熟悉oocss。因为我并不在一个拥有很多前端的的大型网站工作。Oocss对大型网站架构很有用，但不适合单页面作战。</p>
<p>然而虽然我并未应用oocss，但我关注前端工作中的组件重用，样式表的可维护性以及性能。这也是oocss所注重的，所以在某些方面，我的工作跟oocss并没有太大区别。</p>
<h3 id="扩展阅读-1"><a href="#扩展阅读-1" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p> An introduction to OOCSS<br> Object Oriented CSS<br> OOCSS.org<br> Don’t use IDs in CSS selectors?<br> OOCSS——概念篇<br> OOCSS——核心篇   </p>
<h2 id="5-Css3：了解他能做的以及你可以使用的部分"><a href="#5-Css3：了解他能做的以及你可以使用的部分" class="headerlink" title="5. Css3：了解他能做的以及你可以使用的部分"></a>5. Css3：了解他能做的以及你可以使用的部分</h2><p>现在我们打住概念性的讨论，来点干货：css3，虽然这玩意至今没有个确切的定义。</p>
<p>Unlike CSS 2, which is a large single specification defining various features, CSS 3 is divided into several separate documents called “modules”. Each module adds new capabilities or extends features defined in CSS 2, over preserving backward compatibility. […] Due to the modularization, different modules have different stability and statuses.<br>From Cascading Style Sheets on Wikipedia<br>现在我们来讨论下那些已经被现代浏览器实现的一些特性。</p>
<p>当前，从圆角到渐变，从透明到阴影，伪类，随处可见css3。</p>
<p>学习你能做些什么？</p>
<p>我觉得，通过利用css3，你可以减少http请求（图片请求），减少标签数量，减少js的代码量。让我们展开来说：</p>
<ul>
<li>圆角，一行代码代替了用四张小图片拼四个圆角；</li>
<li>透明度与alpha通道的支持： 一行代码代替了一张半透明png；</li>
<li>更先进的选择器：不需要js来写了；</li>
<li>Flexbox：几行代码代替了一整个布局框架；</li>
<li>渐变：几行代码代替了背景平铺的图片；</li>
<li>多背景：不需要多个容器了；</li>
<li>伪类：装饰性的元素不需要额外的标签去定义了。<br>我可以继续讲下去，但是我相信你已经明白了我的意思：知晓你到底可以用css3来做什么。你需要做一个目录么？你可以用纯css来实现，配合CSS counters，你需要做一个漂亮的自定义边框么？你可以利用border-image属性来实现。</li>
</ul>
<p>ss能做无数的事情，css3也一样。你需要了解css力所能及跟力所不能及的。但深入这些，没有什么捷径，只能通过不断的阅读文档，自我探索。比如，你可以用calc（）属性来计算，但如果要搞六列的等高布局，你肯定会杯具。</p>
<p>学习你能用什么？</p>
<p>css最大的问题是浏览器兼容性。在css3里这种情况变得更加糟糕。当你不断试验css3属性时，这将是你萦绕不去的梦魇。</p>
<p>比如最耳熟能详的css3属性：border-radius，杯具的是ie8以下，跟opera mini浏览器仍然不认识这玩意。事实上chrome跟FF对圆角的渲染也不一致。</p>
<p>这对一名前端来说意味着啥呢？优雅降级。如果你做圆角，除了border-radius，你仍然需要利用多图片来拼圆角，努力让各大浏览器保持一致。</p>
<p>当我要使用css时这是我通常的思考步骤：</p>
<ul>
<li>我要用这css干嘛？</li>
<li>我明白我要干嘛了，这是css2规范里的么？</li>
<li>必须的，结束。</li>
<li>不行，跳到第三步</li>
<li>这玩意兼容性怎么样啊</li>
<li>很好的兼容啊，结束</li>
<li>兼容性很一般，跳到第四步</li>
<li>这是锦上添花还是需求啊？</li>
<li>这是锦上添花，那么低端浏览器我就只能优雅降级了。</li>
<li>这是需求啊！跳到第五步</li>
<li><p>我怎么在不兼容的浏览器里对付这个需求呢？<br>现在以渐变为例：</p>
</li>
<li><p>这里要用渐变？</p>
</li>
<li>用吧。。css2里有渐变？</li>
<li>渐变是css3的好吧。</li>
<li>兼容性呢？</li>
<li>还好吧，一般化，ie8以下跟operamini不支持css3渐变（这里明显有误了）</li>
<li>这是锦上添花还是需求啊？</li>
<li>这只是一种更炫的手段，不是重点。不支持的我就用个单色代替吧。</li>
<li>需求要求这里就是用渐变啊！我得找兼容了。</li>
<li>我要如何让它不支持的浏览器上工作</li>
<li>用背景图片吧。<br>如果你用css的时候思考这些步骤，就有思路来处理浏览器兼容性跟优雅降级之类的了。</li>
</ul>
<p>注意！一定要注意你产品的用户！如果你要做移动端app或者移动设备，你可以使劲用css3属性，不用担心。但如果你做个银行系统。。抱歉了，大部分用户都是ie8以下的</p>
<p>Providing fallbacks</p>
<p>根据不同情况，对低端浏览器做兼容可能会很蛋疼，也可能会很烦人。</p>
<p>No fallback or simple fallback</p>
<p>如果有些增强用户体验的特性不被支持，不会带来什么后果的话，你就不用强制兼容了，这太爽了。</p>
<p>也有一些情况兼容起来也比较简单。</p>
<p>总之你需要写两份属性来实现这个效果，作用于老版本浏览器的跟现代浏览器版的。</p>
<pre><code>.my-element {
  border: 1px solid #666;
  border: 1px solid rgba(0,0,0,0.3);
  background: #708090;
  background: hsl(210, 13%, 50%);
}
</code></pre><p>以上的例子中，如果浏览器不识别rgba跟hsl颜色，他会读第一行跟第三行作为降级。那么现代浏览器就会覆盖这些属性，以新属性来渲染。</p>
<p>Modernizr</p>
<p>现在当我们聊到css3的时候，绝对会提及一个库Modernizr。 他可以对浏览器做html5跟css3的特性检测。听起来可能觉得很庞大，但这个库性能非常的好。</p>
<p>无论如何,有时你必须确切地知道如果浏览器支持一个特定的功能。因为,对我们说,提供另一种优雅降级版本，需要知道他的CSS属性。</p>
<pre><code>/* Normal version */
.dropdown {
  opacity: 0;
  pointer-events: none;
}

.trigger:hover .dropdown {
  opacity: 1;
  pointer-events: auto;
    }

/* Fallback with Modernizr */

.no-opacity .dropdown,
.no-pointerevents .dropdown {
  opacity: 1;
  pointer-events: auto;
  display: none;
}

.no-opacity .trigger:hover .dropdown,
.no-pointerevents .trigger:hover .dropdown {
  display: block;
}
</code></pre><p>如果你要提供一个降级方案的话，需要依赖modernizr提供的两个类（.no-opacity 跟.no-pointerevents）但不能同时触发两个。在使用新技术的时候，一定要记得优雅降级，这对用户体验很重要，如果不行，一定要告知用户。</p>
<p>扩展阅读</p>
<p> CSS current work with table of specifications<br> WebPlatform.org<br> Modernizr for feature detection<br> CanIUse for the browser support   </p>
<h2 id="6-渐进增强与优雅降级"><a href="#6-渐进增强与优雅降级" class="headerlink" title="6 . 渐进增强与优雅降级"></a>6 . 渐进增强与优雅降级</h2><p>这两个概念大家肯定耳熟能详了，尤其是优雅降级。其实两者还是有点区别的。</p>
<p>渐进增强</p>
<p>渐进增强，你需要制定一个基本的需求和功能，然后根据浏览器支持度，增强用户体验。你在使用的时候，需要用一些html5属性来提醒某些部分缺失（比如在某某浏览器下可以获得最佳体验）。这是一种根据浏览器引擎增强用户体验的方式。</p>
<p>优雅降级</p>
<p>当你谈到优雅降级的时候，通常是给低端浏览器提供一个不支持特性的替代方案。他的形式通常是从高级到低级讨论的。比如说你需要在canvas标签里面注明，这样当浏览器不支持canvas的时候用户就会知道了。</p>
<pre><code>&lt;canvas&gt;
This page uses HTML5 Canvas. Please use a recent browser to see this content. To get another browser, go to &lt;a href=&quot;http://browsehappy.com/&quot;&gt;BrowseHappy&lt;/a&gt;
&lt;/canvas&gt;
</code></pre><p>他们有何不同？</p>
<p>事实上没啥区别。有些特性呈现在现代浏览器上，而对此在低端浏览器上则上替代方案。这是一个过程：你可以让网页在现代浏览器中的效果很炫，也得顾忌ie，或者置之不理，这完全取决于你。事实上我想说：不同浏览器的用户体验绝对是不同的，即使你需要提供一些基本功能，也请记得利用新特性增强一下你的浏览器或者应用，这是非常好的。</p>
<p>扩展阅读</p>
<p> Progressive enhancement and graceful degradation<br> Understanding progressive enhancement    </p>
<h2 id="7-Css预处理工具"><a href="#7-Css预处理工具" class="headerlink" title="7. Css预处理工具"></a>7. Css预处理工具</h2><p>Css预处理器大概是本年度热门话题了。。这玩意真的好用么？用来干嘛？我需要用么？用什么样的？这是css圈子里的热门话题了。</p>
<p>在这个环节我将以客观的态度来对待这个问题。首先要明确一点：如果你不想用预处理器，请不要用，然后就不会纠结了。不用预处理器并不代表你不是个好前端，仅仅是你可能无法完成一些事情而已。但对待预处理器这件事上，你仍然需要有自己独立的思考。</p>
<p>接下来，什么是预处理器？事实上预处理器就是把一些语句段编译成别的引擎（比如浏览器）需要的语言。各种语言都有预编译，比如html可以使用markdown或者jade。Less，sass跟stylus都是css的预处理器。Coffeescript是js的预处理器，当然还有php的预处理器：cakephp。</p>
<p>要点是什么？</p>
<p>预处理器赋予了css一些基于面向对象语言的特性，比如</p>
<p> 变量（variables）<br> 可传参的函数（functions (with parameters)）<br> 命名空间（namespaces）<br> 嵌套（nesting）<br> 条件语句（conditional statements）<br> 操作（operations）<br> 其他（and many more）<br>听起来很有吸引力,对吧?也许你想要一个例子来找出发生了什么。让我们看下面的CSS导航栏。</p>
<pre><code>.navigation {
  width: 800px;
  width: calc(100%-150px);
}
.navigation li {
  color: #444;
}
.navigation li a {
  text-decoration: none;
}
</code></pre><p>看一个Scss处理的版本</p>
<pre><code>$main-color: #444;

.navigation {
      width: (100%-150px);
      li {
      color: $main-color;
      a {
          text-decoration: none;
      }
      }
}
</code></pre><p>预处理器的基本功能就是把这些表达式翻译成css，结果肯定是相同的，而处理逻辑不同。预处理器会自动处理并输出结果，而不需要calc函数的支持。</p>
<p>最终，你得到了一个可读性更强的（包含嵌套与变量），可维护性更强的（包含变量与函数）的样式表。上面的仅仅是举个例子，在真实的项目里你会体会到这一点。</p>
<p>如何选择？</p>
<p>现在市面上已经有一些不同的css预处理器了，他们各有千秋，同时在细微之处也有区别。选择的余地完全在你手里。这里提供几个主要的选择：</p>
<p> Sass (written in Ruby)<br> LESS (written in JavaScript)<br> Stylus (written in JavaScript)<br> Crush (written in PHP)<br>最好的方式是了解他们是否能最完美的满足你跟你项目的需求。这是由很多因素决定的，如果全部列出来就超出本文的范围了，但你可以找到一些相关的css预处理器的资料。</p>
<p>我对CSS预处理的理解？</p>
<p>我不敢说精通css预处理器，但我非常喜欢。他完善了一些css缺少的非常有用的特性：变量，嵌套以及条件语句。</p>
<p>我之前小玩了一下less，受益匪浅。利用less我完善了以前制作的 CSS Loading Animations，less应用在了循环，自动加前缀以及关键帧上。</p>
<p>我也尝试了sass跟compass。令我震惊的是这玩意安装很简单，在ruby上跑得也很顺畅。所以我觉得Sass + Compass碉堡了。你可以看看我的文章：为啥我抛弃了less选择了sass。</p>
<p>不过我还是需要完全手写普通的css，这也占据了我工作的绝大部分。但最终我觉得大家都会用css预处理器。Css缺乏一些很有用的特性，而预处理器正好填补了这方面的空白。</p>
<p>扩展阅读</p>
<p> Sass vs. LESS vs. Stylus<br> Musing on preprocessing<br> Deep Dive Into CSS Preprocessors<br> Guidelines using OOCSS and CSS preprocessors   </p>
<h2 id="8-与时俱进"><a href="#8-与时俱进" class="headerlink" title="8. 与时俱进"></a>8. 与时俱进</h2><p>语言在不断的进化，css是显著典型。Css草案没完没了，浏览器厂商也在不断的实现这些。</p>
<p>因此，你需要与时俱进，始终对新技术保持跟进，虽然一时半会还用不上，但可以了解chrome开发版本是不是支持了？chrome跟safari，ff，opera未来的版本会不会支持呢？你需要在css解决方案及css问题上，不断的开拓自己的眼界。</p>
<p>扩展阅读</p>
<p> Cascading Style Sheets home page<br> CanIUse.com for browser share and compatibility<br> Mozilla Developer Network for excellent documentation<br> HTML5 Rocks for latest, cutting-edge tutorials and articles   </p>
<h2 id="9-取长补短"><a href="#9-取长补短" class="headerlink" title="9. 取长补短"></a>9. 取长补短</h2><p>读源码是学编程最好的方式之一。css是客户端的，你可以用WebKit Inspector, Dragonfly, Firebug F12等工具看css。同时，互联网是很开放的，大家都乐于开源。</p>
<p>另外一种方法是跟着教程一步步地走，然后从头自己写一遍。遇到问题后瞄一眼答案，然后继续。</p>
<p>如果你觉得自己已经熟悉css了，想深入css，你需要写一些demo来测试那些试验性的css属性，或者解决一个问题的不同思路。学无止境。</p>
<p>前阵子Chris Coyier, Tim Sabat 和 Alex Vazquez三位建立了CodePen，他是一个在线分享前端代码的平台，可以自由的添加你需要的库，比如jQuery, jQuery UI, MooTools, YUI, Prototype, Zepto, Dojo, Ext JS, PrefixFree等等。同时也可以使用一些预处理器比如HAML, Markdown, Slim, LESS, SCSS, Sass, CoffeeScript。</p>
<ol>
<li>熟能生巧</li>
</ol>
<p>实践出真知。所以最好的建议：不断的练习。熟能生巧。并不是让你不停的从头建站。你可以从dribbble上找些图用纯css实现一下。最终你可能不一定会用到，但你学到了，这就足够了。</p>
<p>我之前也说了，掌握基础，了解技巧。Css有很多坑，填坑是csser日常工作的一部分。而坑都是写代码的时候踩出来的，只有踩过了，解决过了，才能提高。</p>
<p>同时我建议你多多分享自己的代码，让大家提提意见，取百家之长方为上。你可以扔到JSFiddle里然后分享到群里，问问大家有没有可以吐槽的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[软设计原则]]></title>
      <url>http://yoursite.com/2016/07/22/%E8%BD%AF%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
      <content type="html"><![CDATA[<p>设计模式遵循的一般原则：</p>
<h2 id="1-避免重复原则（DRY-–-Don’t-repeat-yourself）"><a href="#1-避免重复原则（DRY-–-Don’t-repeat-yourself）" class="headerlink" title="1.避免重复原则（DRY – Don’t repeat yourself）"></a>1.避免重复原则（DRY – Don’t repeat yourself）</h2><p>编程的最基本原则是避免重复。在程序代码中总会有很多结构体，如循环、函数、类等等。一旦你重复某个语句或概念，就会很容易形成一个抽象体。</p>
<h2 id="2-抽象原则（Abstraction-Principle-）"><a href="#2-抽象原则（Abstraction-Principle-）" class="headerlink" title="2.抽象原则（Abstraction Principle ）"></a>2.抽象原则（Abstraction Principle ）</h2><p>与DRY原则相关。要记住，程序代码中每一个重要的功能，只能出现在源代码的一个位置。</p>
<h2 id="3-简单原则（Keep-It-Simple-and-Stupid-）"><a href="#3-简单原则（Keep-It-Simple-and-Stupid-）" class="headerlink" title="3.简单原则（Keep It Simple and Stupid ）"></a>3.简单原则（Keep It Simple and Stupid ）</h2><p>简单是软件设计的目标，简单的代码占用时间少，漏洞少，并且易于修改。</p>
<h2 id="4-避免创建你不要的代码-Avoid-Creating-a-YAGNI-You-aren’t-going-to-need-it"><a href="#4-避免创建你不要的代码-Avoid-Creating-a-YAGNI-You-aren’t-going-to-need-it" class="headerlink" title="4.避免创建你不要的代码 Avoid Creating a YAGNI (You aren’t going to need it)"></a>4.避免创建你不要的代码 Avoid Creating a YAGNI (You aren’t going to need it)</h2><p>除非你需要它，否则别创建新功能。</p>
<a id="more"></a>
<h2 id="5-尽可能做可运行的最简单的事（Do-the-simplest-thing-that-could-possibly-work）"><a href="#5-尽可能做可运行的最简单的事（Do-the-simplest-thing-that-could-possibly-work）" class="headerlink" title="5.尽可能做可运行的最简单的事（Do the simplest thing that could possibly work）"></a>5.尽可能做可运行的最简单的事（Do the simplest thing that could possibly work）</h2><p>尽可能做可运行的最简单的事。在编程中，一定要保持简单原则。作为一名程序员不断的反思“如何在工作中做到简化呢？”这将有助于在设计中保持简单的路径。</p>
<h2 id="6-别让我思考-Don’t-make-me-think"><a href="#6-别让我思考-Don’t-make-me-think" class="headerlink" title="6.别让我思考(Don’t make me think )"></a>6.别让我思考(Don’t make me think )</h2><p>这是Steve Krug一本书的标题，同时也和编程有关。所编写的代码一定要易于读易于理解，这样别人才会欣赏，也能够给你提出合理化的建议。相反，若是繁杂难解的程序，其他人总是会避而远之的。</p>
<h2 id="7-开闭原则-Open-Closed-Principle"><a href="#7-开闭原则-Open-Closed-Principle" class="headerlink" title="7.开闭原则(Open/Closed Principle)"></a>7.开闭原则(Open/Closed Principle)</h2><p>你所编写的软件实体（类、模块、函数等）最好是开放的，这样别人可以拓展开发。不过，对于你的代码，得限定别人不得修改。换句话说，别人可以基于你的代码进行拓展编写，但却不能修改你的代码。</p>
<h2 id="8-代码维护-Write-Code-for-the-Maintainer"><a href="#8-代码维护-Write-Code-for-the-Maintainer" class="headerlink" title="8.代码维护(Write Code for the Maintainer)"></a>8.代码维护(Write Code for the Maintainer)</h2><p>一个优秀的代码，应当使本人或是他人在将来都能够对它继续编写或维护。代码维护时，或许本人会比较容易，但对他人却比较麻烦。因此你写的代码要尽可能保证他人能够容易维护。用书中原话说“如果一个维护者不再继续维护你的代码，很可能他就有想杀了你的冲动。”</p>
<h2 id="9-最小惊讶原则-Principle-of-least-astonishment"><a href="#9-最小惊讶原则-Principle-of-least-astonishment" class="headerlink" title="9.最小惊讶原则(Principle of least astonishment)"></a>9.最小惊讶原则(Principle of least astonishment)</h2><p>最小惊讶原则通常是在用户界面方面引用，但同样适用于编写的代码。代码应该尽可能减少让读者惊喜。也就是说，你编写的代码只需按照项目的要求来编写。其他华丽的功能就不必了，以免弄巧成拙。</p>
<h2 id="10-单一责任原则-Single-Responsibility-Principle"><a href="#10-单一责任原则-Single-Responsibility-Principle" class="headerlink" title="10.单一责任原则(Single Responsibility Principle)"></a>10.单一责任原则(Single Responsibility Principle)</h2><p>某个代码的功能，应该保证只有单一的明确的执行任务。</p>
<h2 id="11-低耦合原则-Minimize-Coupling"><a href="#11-低耦合原则-Minimize-Coupling" class="headerlink" title="11.低耦合原则(Minimize Coupling)"></a>11.低耦合原则(Minimize Coupling)</h2><p>代码的任何一个部分应该减少对其他区域代码的依赖关系。尽量不要使用共享参数。低耦合往往是完美结构系统和优秀设计的标志。</p>
<h2 id="12-最大限度凝聚原则-Maximize-Cohesion"><a href="#12-最大限度凝聚原则-Maximize-Cohesion" class="headerlink" title="12.最大限度凝聚原则(Maximize Cohesion)"></a>12.最大限度凝聚原则(Maximize Cohesion)</h2><p>相似的功能代码应尽量放在一个部分。   High Cohesion， Low Coupling！</p>
<h2 id="13-隐藏实现细节（Hide-Implementation-Details）"><a href="#13-隐藏实现细节（Hide-Implementation-Details）" class="headerlink" title="13.隐藏实现细节（Hide Implementation Details）"></a>13.隐藏实现细节（Hide Implementation Details）</h2><p>隐藏实现细节原则，当其他功能部分发生变化时，能够尽可能降低对其他组件的影响。</p>
<h2 id="14-迪米特法则又叫作最少知识原则-Law-of-Demeter"><a href="#14-迪米特法则又叫作最少知识原则-Law-of-Demeter" class="headerlink" title="14.迪米特法则又叫作最少知识原则(Law of Demeter)"></a>14.迪米特法则又叫作最少知识原则(Law of Demeter)</h2><p>该代码只和与其有直接关系的部分连接。（比如：该部分继承的类，包含的对象，参数传递的对象等）。</p>
<h2 id="15-避免过早优化-Avoid-Premature-Optimization"><a href="#15-避免过早优化-Avoid-Premature-Optimization" class="headerlink" title="15.避免过早优化(Avoid Premature Optimization)"></a>15.避免过早优化(Avoid Premature Optimization)</h2><p>除非你的代码运行的比你想像中的要慢，否则别去优化。假如你真的想优化，就必须先想好如何用数据证明，它的速度变快了。<br>“过早的优化是一切罪恶的根源”——Donald Knuth</p>
<h2 id="16-代码重用原则（Code-Reuse-is-Good）"><a href="#16-代码重用原则（Code-Reuse-is-Good）" class="headerlink" title="16.代码重用原则（Code Reuse is Good）"></a>16.代码重用原则（Code Reuse is Good）</h2><p>重用代码能提高代码的可读性，缩短开发时间。</p>
<h2 id="17-关注点分离（Separation-of-Concerns）"><a href="#17-关注点分离（Separation-of-Concerns）" class="headerlink" title="17.关注点分离（Separation of Concerns）"></a>17.关注点分离（Separation of Concerns）</h2><p>不同领域的功能，应该由不同的代码和最小重迭的模块组成。</p>
<h2 id="18-拥抱改变（Embrace-Change）"><a href="#18-拥抱改变（Embrace-Change）" class="headerlink" title="18.拥抱改变（Embrace Change）"></a>18.拥抱改变（Embrace Change）</h2><p>这是Kent Beck一本书的标题，同时也被认为是极限编程和敏捷方法的宗旨。<br>许多其他原则都是基于这个概念的，即你应该积极面对变化。事实上，一些较老的编程原则如最小化耦合原则都是为了使代码能够容易变化。无论你是否是个极限编程者，基于这个原则去编写代码会让你的工作变得更有意义。</p>
<p><code>作者简介：Christopher Diggins是加拿大一位有25年编程经验的资深技术人员，曾效力于Microsoft和AutoDesk，并创办过两家赢利的互联网公司。</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何做到jQuery-free?]]></title>
      <url>http://yoursite.com/2016/06/21/%E5%A6%82%E4%BD%95%E5%81%9A%E5%88%B0jQuery-free/</url>
      <content type="html"><![CDATA[<h1 id="如何做到-jQuery-free？"><a href="#如何做到-jQuery-free？" class="headerlink" title="如何做到 jQuery-free？"></a>如何做到 jQuery-free？</h1><p>jQuery是现在最流行的JavaScript工具库。</p>
<p>据统计，目前全世界57.3%的网站使用它。也就是说，10个网站里面，有6个使用jQuery。如果只考察使用工具库的网站，这个比例就会上升到惊人的91.7%。</p>
<p>虽然jQuery如此受欢迎，但是它臃肿的体积也让人头痛不已。jQuery 2.0的原始大小为235KB，优化后为81KB；如果是支持IE6、7、8的jQuery 1.8.3，原始大小为261KB，优化后为91KB。</p>
<p>这样的体积，即使是宽带环境，完全加载也需要1秒或更长，更不要说移动设备了。这意味着，如果你使用了jQuery，用户至少延迟1秒，才能看到网页效果。考虑到本质上，jQuery只是一个操作DOM的工具，我们不仅要问：如果只是为了几个网页特效，是否有必要动用这么大的库？<br><a id="more"></a></p>
<p>2006年，jQuery诞生的时候，主要用于消除不同浏览器的差异（主要是IE6），为开发者提供一个简洁的统一接口。相比当时，如今的情况已经发生了很大的变化。IE的市场份额不断下降，以ECMAScript为基础的JavaScript标准语法，正得到越来越广泛的支持。开发者直接使用JavScript标准语法，就能同时在各大浏览器运行，不再需要通过jQuery获取兼容性。</p>
<p>下面就探讨如何用JavaScript标准语法，取代jQuery的一些主要功能，做到jQuery-free。</p>
<h2 id="一、选取DOM元素"><a href="#一、选取DOM元素" class="headerlink" title="一、选取DOM元素"></a>一、选取DOM元素</h2><p>jQuery的核心是通过各种选择器，选中DOM元素，可以用querySelectorAll方法模拟这个功能。<br>　　var $ = document.querySelectorAll.bind(document);<br>这里需要注意的是，querySelectorAll方法返回的是NodeList对象，它很像数组（有数字索引和length属性），但不是数组，不能使用pop、push等数组特有方法。如果有需要，可以考虑将Nodelist对象转为数组。<br>　　myList = Array.prototype.slice.call(myNodeList);</p>
<h2 id="二、DOM操作"><a href="#二、DOM操作" class="headerlink" title="二、DOM操作"></a>二、DOM操作</h2><p>DOM本身就具有很丰富的操作方法，可以取代jQuery提供的操作方法。<br>尾部追加DOM元素。</p>
<pre><code>// jQuery写法
$(parent).append($(child));
// DOM写法
parent.appendChild(child)
</code></pre><p>头部插入DOM元素。</p>
<pre><code>// jQuery写法
$(parent).prepend($(child));
parent.insertBefore(child, parent.childNodes[0])
</code></pre><p>删除DOM元素。</p>
<pre><code>// jQuery写法
$(child).remove()
// DOM写法
child.parentNode.removeChild(child)
</code></pre><h2 id="三、事件的监听"><a href="#三、事件的监听" class="headerlink" title="三、事件的监听"></a>三、事件的监听</h2><p>jQuery的on方法，完全可以用addEventListener模拟。</p>
<pre><code>Element.prototype.on = Element.prototype.addEventListener;
</code></pre><p>为了使用方便，可以在NodeList对象上也部署这个方法。</p>
<pre><code>NodeList.prototype.on = function (event, fn) {
　　[][&apos;forEach&apos;].call(this, function (el) {
　　　　el.on(event, fn);
　　});
　return this;
};
</code></pre><p>四、事件的触发<br>jQuery的trigger方法则需要单独部署，相对复杂一些。</p>
<pre><code>Element.prototype.trigger = function (type, data) {
　　var event = document.createEvent(&apos;HTMLEvents&apos;);
　event.initEvent(type, true, true);
　　event.data = data || {};
　　event.eventName = type;
　　event.target = this;
  　this.dispatchEvent(event);
    　return this;
};
</code></pre><p>在NodeList对象上也部署这个方法。</p>
<pre><code>NodeList.prototype.trigger = function (event) {
　　[][&apos;forEach&apos;].call(this, function (el) {
　　　el[&apos;trigger&apos;](event);
　});
　　return this;
};
</code></pre><h2 id="五、document-ready"><a href="#五、document-ready" class="headerlink" title="五、document.ready"></a>五、document.ready</h2><p>目前的最佳实践，是将JavaScript脚本文件都放在页面底部加载。这样的话，其实document.ready方法（jQuery简写为$(function)）已经不必要了，因为等到运行的时候，DOM对象已经生成了。</p>
<h2 id="六、attr方法"><a href="#六、attr方法" class="headerlink" title="六、attr方法"></a>六、attr方法</h2><p>jQuery使用attr方法，读写网页元素的属性。</p>
<pre><code>$(&quot;#picture&quot;).attr(&quot;src&quot;, &quot;http://url/to/image&quot;);
</code></pre><p>DOM元素允许直接读取属性值，写法要简洁许多。</p>
<pre><code>$(&quot;#picture&quot;).src = &quot;http://url/to/image&quot;;
</code></pre><p>需要注意，input元素的this.value返回的是输入框中的值，链接元素的this.href返回的是绝对URL。如果需要用到这两个网页元素的属性准确值，可以用</p>
<pre><code>this.getAttribute(&apos;value&apos;)和this.getAttibute(&apos;href&apos;)。
</code></pre><h2 id="七、addClass方法"><a href="#七、addClass方法" class="headerlink" title="七、addClass方法"></a>七、addClass方法</h2><p>jQuery的addClass方法，用于为DOM元素添加一个class。</p>
<pre><code>$(&apos;body&apos;).addClass(&apos;hasJS&apos;);
</code></pre><p>DOM元素本身有一个可读写的className属性，可以用来操作class。</p>
<pre><code>document.body.className = &apos;hasJS&apos;;
// or
document.body.className += &apos; hasJS&apos;;
</code></pre><p>HTML 5还提供一个classList对象，功能更强大（IE 9不支持）。</p>
<pre><code>document.body.classList.add(&apos;hasJS&apos;);
document.body.classList.remove(&apos;hasJS&apos;);
document.body.classList.toggle(&apos;hasJS&apos;);
document.body.classList.contains(&apos;hasJS&apos;);
</code></pre><h2 id="八、CSS"><a href="#八、CSS" class="headerlink" title="八、CSS"></a>八、CSS</h2><p>jQuery的css方法，用来设置网页元素的样式。</p>
<pre><code>$(node).css( &quot;color&quot;, &quot;red&quot; );
</code></pre><p>DOM元素有一个style属性，可以直接操作。</p>
<pre><code>element.style.color = &quot;red&quot;;;
// or
element.style.cssText += &apos;color:red&apos;;
</code></pre><h2 id="九、数据储存"><a href="#九、数据储存" class="headerlink" title="九、数据储存"></a>九、数据储存</h2><p>jQuery对象可以储存数据。</p>
<pre><code>$(&quot;body&quot;).data(&quot;foo&quot;, 52);
</code></pre><p>HTML 5有一个dataset对象，也有类似的功能（IE 10不支持），不过只能保存字符串。</p>
<pre><code>element.dataset.user = JSON.stringify(user);
element.dataset.score = score;
</code></pre><h2 id="十、Ajax"><a href="#十、Ajax" class="headerlink" title="十、Ajax"></a>十、Ajax</h2><p>jQuery的Ajax方法，用于异步操作。</p>
<pre><code>$.ajax({
　　type: &quot;POST&quot;,
　　url: &quot;some.php&quot;,
　　data: { name: &quot;John&quot;, location: &quot;Boston&quot; }
}).done(function( msg ) {
　　alert( &quot;Data Saved: &quot; + msg );
});
</code></pre><p>我们可以定义一个request函数，模拟Ajax方法。</p>
<pre><code>function request(type, url, opts, callback) {
　　var xhr = new XMLHttpRequest();
　　if (typeof opts === &apos;function&apos;) {
　　　　callback = opts;
　　　　opts = null;
　　}
　　xhr.open(type, url);
　　var fd = new FormData();
　　if (type === &apos;POST&apos; &amp;&amp; opts) {
　　　　for (var key in opts) {
　　　　　　fd.append(key, JSON.stringify(opts[key]));
　　　　}
　　}
　　xhr.onload = function () {
　　　　callback(JSON.parse(xhr.response));
　　};
　　xhr.send(opts ? fd : null);
}
</code></pre><p>然后，基于request函数，模拟jQuery的get和post方法。</p>
<pre><code>var get = request.bind(this, &apos;GET&apos;);
var post = request.bind(this, &apos;POST&apos;);
</code></pre><p>　　## 十一、动画<br>jQuery的animate方法，用于生成动画效果。</p>
<pre><code>$foo.animate(&apos;slow&apos;, { x: &apos;+=10px&apos; })；
</code></pre><p>jQuery的动画效果，很大部分基于DOM。但是目前，CSS 3的动画远比DOM强大，所以可以把动画效果写进CSS，然后通过操作DOM元素的class，来展示动画。</p>
<pre><code>foo.classList.add(&apos;animate&apos;)；
</code></pre><p>如果需要对动画使用回调函数，CSS 3也定义了相应的事件。</p>
<pre><code>el.addEventListener(&quot;webkitTransitionEnd&quot;, transitionEnded);
el.addEventListener(&quot;transitionend&quot;, transitionEnded);
</code></pre><h2 id="十二、替代方案"><a href="#十二、替代方案" class="headerlink" title="十二、替代方案"></a>十二、替代方案</h2><p>由于jQuery体积过大，替代方案层出不穷。</p>
<p>其中，最有名的是zepto.js。它的设计目标是以最小的体积，做到最大兼容jQuery的API。zepto.js 1.0版的原始大小是55KB，优化后是29KB，gzip压缩后为10KB。<br>如果不求最大兼容，只希望模拟jQuery的基本功能，那么，min.js优化后只有200字节，而dolla优化后是1.7KB。</p>
<p>此外，jQuery本身采用模块设计，可以只选择使用自己需要的模块。具体做法参见它的github网站，或者使用专用的Web界面。</p>
<h2 id="十三、参考链接"><a href="#十三、参考链接" class="headerlink" title="十三、参考链接"></a>十三、参考链接</h2><p>　　- Remy Sharp，I know jQuery. Now what?<br>　　- Hemanth.HM，Power of Vanilla JS<br>　　- Burke Holland，5 Things You Should Stop Doing With jQuery<br>（完）</p>
<h3 id="文章转载自-lt-阮一峰博客-gt"><a href="#文章转载自-lt-阮一峰博客-gt" class="headerlink" title="文章转载自&lt;阮一峰博客&gt;"></a>文章转载自<a href="http://www.ruanyifeng.com/blog/2013/05/jquery-free.html" target="_blank" rel="external">&lt;阮一峰博客&gt;</a></h3>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一些蛋疼的JavaScript语法特性面试题]]></title>
      <url>http://yoursite.com/2016/05/23/%E4%B8%80%E4%BA%9B%E8%9B%8B%E7%96%BC%E7%9A%84JavaScript%E8%AF%AD%E6%B3%95%E7%89%B9%E6%80%A7%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p>JavaScript有很多地方和我们熟知的C、Java等的编程习惯不同，这些不同会产生很多让人意想不到的事情。前段时间在知乎有人发了写Javascrtip试题，觉得挺好玩的，这里跟大家分享一下。<br><a id="more"></a></p>
<h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><pre><code>(function () { 
    return typeof arguments; 
})(); 
A. &quot;object&quot;
B. &quot;array&quot;
C. &quot;arguments&quot;
D. &quot;undefined&quot;
</code></pre><p><code>答案：A</code></p>
<h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><pre><code>var f = function g() {
        return 23;
    };
typeof g();
A. &quot;number&quot;
B. &quot;undefined&quot;
C. &quot;function&quot;
D. Eorror
</code></pre><p><code>答案：D</code></p>
<h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><pre><code>(function (x) {
    delete x;
    return x;
})(1);
A. 1
B. null
C. undefined
D. Error
</code></pre><p><code>答案：A</code></p>
<h3 id="04"><a href="#04" class="headerlink" title="04"></a>04</h3><pre><code>var y = 1,
    x = y = typeof x;
x;
A. 1
B. &quot;number&quot;
C. undefined
D. &quot;undefined&quot;
</code></pre><p><code>答案： D</code></p>
<h3 id="05"><a href="#05" class="headerlink" title="05"></a>05</h3><pre><code>(function f(f) {
    return typeof f();
})(function () {
    return 1;
});
A. &quot;number&quot;
B. &quot;undefined&quot;
C. &quot;function&quot;
D. Error
</code></pre><p><code>答案：A</code></p>
<h3 id="06"><a href="#06" class="headerlink" title="06"></a>06</h3><pre><code>var foo = {
    bar: function () {
        return this.baz;
    },
    baz: 1
};
(function () {
    return typeof arguments[0]();
})(foo.bar);
A. &quot;undefined&quot;
B. &quot;object&quot;
C. &quot;number&quot;
D. &quot;function&quot;
</code></pre><p><code>答案：A</code></p>
<h3 id="07"><a href="#07" class="headerlink" title="07"></a>07</h3><pre><code>var foo = {
    bar: function () {
        return this.baz;
    },
    baz: 1
};
typeof (f = foo.bar)();
A. &quot;undefined&quot;
B. &quot;object&quot;
C. &quot;number&quot;
D. &quot;function&quot;
</code></pre><p><code>答案：A</code></p>
<h3 id="08"><a href="#08" class="headerlink" title="08"></a>08</h3><pre><code>var f = (function f() {
    return &quot;1&quot;;
}, function g() {
    return 2;
})();
typeof f;
A. &quot;string&quot;
B. &quot;number&quot;
C. &quot;function&quot;
D. &quot;undefined&quot;
</code></pre><p><code>答案： B</code></p>
<h3 id="09"><a href="#09" class="headerlink" title="09"></a>09</h3><pre><code>var x = 1;
if (function f() {}) {
    x += typeof f;
}
x;
A. 1
B. &quot;1function&quot;
C. &quot;1undefined&quot;
D. NaN
</code></pre><p><code>答案： C</code></p>
<h3 id="10"><a href="#10" class="headerlink" title="10"></a>10</h3><pre><code>var x = [typeof x, typeof y][1];
typeof typeof x;
A. &quot;number&quot;
B. &quot;string&quot;
C. &quot;undefined&quot;
D. &quot;object&quot;
</code></pre><p><code>答案： B</code></p>
<h3 id="11"><a href="#11" class="headerlink" title="11"></a>11</h3><pre><code>(function (foo) {
    return typeof foo.bar;
})({
    foo: {
        bar: 1
    }
});
A、“undefined”
B、“object”
C、“number”
D、Error
</code></pre><p><code>答案： A</code></p>
<h3 id="12"><a href="#12" class="headerlink" title="12"></a>12</h3><pre><code>(function f() {
    function f() {
        return 1;
    }
    return f();
    function f() {
        return 2;
    }
})();
A、1
B、2
C、Error (e.g. “Too much recursion”)
D、undefined
</code></pre><p><code>答案：B</code></p>
<h3 id="13"><a href="#13" class="headerlink" title="13"></a>13</h3><pre><code>function f() {
    return f;
}
new f() instanceof f;
A、true
B、false
</code></pre><p><code>答案：B</code></p>
<h3 id="14"><a href="#14" class="headerlink" title="14"></a>14</h3><pre><code>with (function(x, undefined){}) length;
A、1
B、2
C、undefined
D、Error
</code></pre><p><code>答案：B</code></p>
<p>具体答案大家可以自己运行得出，为什么会得出这样的结果，我也有一些不懂的地方，怕误人子弟，所以这里就不解答这里的问题了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于前端的几道经典面试题]]></title>
      <url>http://yoursite.com/2016/05/23/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E5%87%A0%E9%81%93%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<p><br></p>
<p>前端面试的时候一般会考察你对JavaScript中函数作用域的理解，而且还会考察你对this的理解</p>
<p>年前刚刚离职了，分享下我曾经出过的一道面试题，此题是我出的一套前端面试题中的最后一题，用来考核面试者的JavaScript的综合能力，很可惜到目前为止的将近两年中，几乎没有人能够完全答对，并非多难只是因为大多面试者过于轻视他。<br><a id="more"></a><br>此题是我综合之前的开发经验以及遇到的JS各种坑汇集而成。此题涉及的知识点众多，包括变量定义提升、this指针指向、运算符优先级、原型、继承、全局变量污染、对象属性及原型属性优先级等等。</p>
<h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><pre><code>function Foo(){
    getName = function(){
        alert(1);
    }
    return this;
}
function getName(){
    alert(5);
}
var getName;
Foo.getName = function(){
    alert(2);
}
Foo.prototype.getName = function(){
    alert(3);
}
getName= function(){
    alert(4);
}

Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo.getName();// 2
new Foo().getName();// 1 || 3
new new Foo().getName();//1 || 3
</code></pre><h3 id="变量声明提升"><a href="#变量声明提升" class="headerlink" title="变量声明提升"></a>变量声明提升</h3><p>例如下边代码：</p>
<pre><code>console.log(&apos;x&apos; in window);//true
var x;
x = 0; 
</code></pre><p>代码执行时js引擎沪江声明语句提升到代码最上方，变为：</p>
<pre><code>var x;
console.log(&apos;x&apos; in window);//true
x = 0;
</code></pre><h3 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>var getName 与 function getName 都是声明语句，区别在于 var getName 是函数表达式，而 function getName 是函数声明。关于JS中的各种函数创建方式可以看 <a href="http://www.codeceo.com/article/javascript-closure-interview.html" target="_blank" rel="external">大部分人都会做错的经典JS闭包面试题</a>这篇文章有详细说明。</p>
<p>函数表达式的最大问题就是在于js会将此代码拆分成两行代码分别执行。<br>例如：</p>
<pre><code>console.log(x);//输出：function x(){}
var x=1;
function x(){}
</code></pre><p>实际执行的代码为，先将 var x=1 拆分为 var x; 和 x = 1; 两行，再将 var x; 和 function x(){} 两行提升至最上方变成：</p>
<pre><code>var x;
x=1;
function x(){}；
console.log(x);
</code></pre><p>同理，原题中代码最终执行时的是：</p>
<pre><code>function Foo() {
    getName = function () { alert (1); };
    return this;
}
var getName;//只提升变量声明
function getName() { alert (5);}//提升函数声明，覆盖var的声明

Foo.getName = function () { alert (2);};
Foo.prototype.getName = function () { alert (3);};
getName = function () { alert (4);};//最终的赋值再次覆盖function     getName声明

getName();//最终输出4
</code></pre><h3 id="js运算符优先级"><a href="#js运算符优先级" class="headerlink" title="js运算符优先级:"></a>js运算符优先级:</h3><p><a href="http://www.kekaoyun.com/2e1fed9cf8691bf9" target="_blank" rel="external"><img src="http://i4.buimg.com/2e1fed9cf8691bf9.png"></a></p>
<h3 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h3><p>传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。</p>
<p>而在js中构造函数可以有返回值也可以没有。</p>
<h4 id="1、没有返回值则按照其他语言一样返回实例化对象"><a href="#1、没有返回值则按照其他语言一样返回实例化对象" class="headerlink" title="1、没有返回值则按照其他语言一样返回实例化对象"></a>1、没有返回值则按照其他语言一样返回实例化对象</h4><h4 id="2、若有返回值则检查其返回值是否为引用类型。"><a href="#2、若有返回值则检查其返回值是否为引用类型。" class="headerlink" title="2、若有返回值则检查其返回值是否为引用类型。"></a>2、若有返回值则检查其返回值是否为引用类型。</h4><p>如果是非引用类型，如基本类型（string,number,boolean,null,undefined）则与无返回值相同，实际返回其实例化对象。</p>
<h4 id="3、如果返回值是引用类型，则实际返回值-为这个引用类型"><a href="#3、如果返回值是引用类型，则实际返回值-为这个引用类型" class="headerlink" title="3、如果返回值是引用类型，则实际返回值 为这个引用类型"></a>3、如果返回值是引用类型，则实际返回值 为这个引用类型</h4><p>原题中，返回的是this，而this在构造函数中本来就代表当前实例化对象，遂最终Foo函数返回实例化对象。</p>
<p>之后调用实例化对象的getName函数，因为在Foo构造函数中没有为实例化对象添加任何属性，遂到当前对象的原型对象（prototype）中寻找getName，找到了。</p>
<p>遂最终输出3。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[js面向对象编程]]></title>
      <url>http://yoursite.com/2016/05/23/js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p><a href="http://www.kekaoyun.com/33d18274d72e81e7" target="_blank" rel="external"><img src="http://i4.buimg.com/33d18274d72e81e7.jpg"></a></p>
<h3 id="this的使用总结"><a href="#this的使用总结" class="headerlink" title="this的使用总结"></a>this的使用总结</h3><p>全局作用域直接调用 指向window</p>
<pre><code>var haha = “哈哈”；
console.log(this.haha);
//指向window
</code></pre><p>普通函数调用</p>
<pre><code>function fn9 () {
    this.name = &apos;123&apos;;
    this.age = &apos;30&apos;;
}
window.fn9();
//指向window

function fn9 () {
    function heihei(){
    console.log(this+&apos;heihei&apos;)
    }
    console.log(this+&apos;&apos;123);
}
window.fn9();
//指向window
</code></pre><p>作为对象属性调用 指向该对象</p>
<pre><code>varv obj = {
    name:&apos;123&apos;
    fn3 :function(){
        console.log(this.name);    
    }
}
obj.fn3();
//指向该对象
</code></pre><p>call apply的使用</p>
<pre><code>var age = 20;

var obj = {
    age:&quot;18&quot;,
    fn2:function(){
        console.log(this.age)
    }
}
obj.fn2.call(this,window);
</code></pre><h3 id="function-函数：1。返回值-2-prototype对象"><a href="#function-函数：1。返回值-2-prototype对象" class="headerlink" title="function 函数：1。返回值 2.prototype对象"></a>function 函数：1。返回值 2.prototype对象</h3><p>所有的对象都有proto属性</p>
<h3 id="后记。经典面试题"><a href="#后记。经典面试题" class="headerlink" title="后记。经典面试题"></a>后记。经典面试题</h3><pre><code>function Foo(){
getName = function(){
    alert(1);
}
return this;
}
function getName(){
    alert(5);
}
var getName;
Foo.getName = function(){
    alert(2);
}
Foo.prototype.getName = function(){
    alert(3);
}
getName= function(){
    alert(4);
}

Foo.getName();//2
getName();//4
Foo().getName();//1
getName();//1
new Foo.getName();// 2
new Foo().getName();// 3
new new Foo().getName();// 3
</code></pre><p><code>hasOwnProperty检查该对象的属性是否是自身的，是的话返回true，不是的话返回false</code></p>
<p>使用示例：</p>
<pre><code>console.log(obj.hasOwnProperty(&quot;eat&quot;));
</code></pre><p><code>__proto__</code></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[bootstrap的使用]]></title>
      <url>http://yoursite.com/2016/05/18/bootstrap%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[jade-源于 Node.js的HTML模板引擎]]></title>
      <url>http://yoursite.com/2016/05/17/jade-%E6%BA%90%E4%BA%8E%20Node.js%20%E7%9A%84%20HTML%20%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/</url>
      <content type="html"><![CDATA[<h2 id="jade源于-Node-js-的-HTML-模板引擎"><a href="#jade源于-Node-js-的-HTML-模板引擎" class="headerlink" title="jade源于 Node.js 的 HTML 模板引擎"></a><a href="http://www.w3cplus.com/html/jade.html" target="_blank" rel="external">jade</a>源于 Node.js 的 HTML 模板引擎</h2><p>Jade 是一个高性能的模板引擎，它深受 Haml 影响，它是用 JavaScript 实现的，并且可以供 Node 使用。</p>
<a id="more"></a>
<p>特性</p>
<ul>
<li>客户端支持</li>
<li>代码高可读</li>
<li>灵活的缩进</li>
<li>块展开</li>
<li>Mixins</li>
<li>静态包含</li>
<li>属性改写</li>
<li>安全，默认代码是转义的</li>
<li>运行时和编译时上下文错误报告</li>
<li>命令行下编译jade模板</li>
<li>HTML5 模式 (使用 !!! 5 文档类型)</li>
<li>在内存中缓存(可选)</li>
<li>合并动态和静态标签类</li>
<li>可以通过 filters 修改树</li>
<li>模板继承</li>
<li>原生支持 Express JS</li>
<li>通过 each 枚举对象、数组甚至是不能枚举的对象</li>
<li>块注释</li>
<li>没有前缀的标签</li>
<li>AST Filters</li>
<li>过滤器</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>1.初始化项目依赖</p>
<pre><code>$ npm init 
</code></pre><p>2.安装作为项目的开发依赖：</p>
<pre><code>$ npm install gulp --save-dev

$ npm install gulp-jade --save-dev

$ npm install hulp-concat --svae-dev
</code></pre><p>3,在项目根目录中的gulpflie.js文件中配置：</p>
<pre><code>var gulp =require(&apos;gulp&apos;);
var jade = require(&apos;gulp-jade&apos;);


gulp.task(&apos;default&apos;,function () {
gulp.src(&apos;view/*.jade&apos;)
    .pipe(jade())
    .pipe(gulp.dest(&apos;desk/html/&apos;));
});
</code></pre><h2 id="相关语法"><a href="#相关语法" class="headerlink" title="相关语法"></a>相关语法</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>以p标签为例</p>
<pre><code>p
</code></pre><p>会转换为：</p>
<pre><code>&lt;p&gt;&lt;/p&gt;
</code></pre><p>jade能自动识别自闭和标签:</p>
<pre><code>input
</code></pre><p>会转换为：</p>
<pre><code>&lt;input/&gt;
</code></pre><h3 id="文本"><a href="#文本" class="headerlink" title="文本"></a>文本</h3><p>标签中添加文本</p>
<pre><code>p 欢迎加入wandoujia-fe
</code></pre><p>会转换为：</p>
<pre><code>&lt;p&gt;欢迎加入wandoujia-fe&lt;/p&gt;
</code></pre><p>标签中嵌套标签</p>
<p>直接跟写html一样就行</p>
<pre><code>p Welcome to wandoujia fe, we want &lt;b&gt;you&lt;/b&gt;
</code></pre><p>会转换为：</p>
<pre><code>&lt;p&gt;Welcome to wandoujia fe, we want &lt;b&gt;you&lt;/b&gt;&lt;/p&gt;
</code></pre><p>标签中有大段的块内容</p>
<p>方式一：在标签后面添加 .</p>
<p>比如一段js代码，注意是script后面有一个.</p>
<pre><code>script.
    console.log(&apos;Welcome to join wandoujia-fe&apos;)
    console.log(&apos;We want you&apos;)
</code></pre><p>会转换为：</p>
<pre><code>&lt;script&gt;
    console.log(&apos;Welcome to join wandoujia-fe&apos;)
    console.log(&apos;We want you&apos;)
&lt;/script&gt;
</code></pre><p>方式二：每段前面添加|</p>
<pre><code>script
    | console.log(&apos;Welcome to join wandoujia-fe&apos;)
    | console.log(&apos;We want you&apos;)
</code></pre><p>会转换为：</p>
<pre><code>&lt;script&gt;
    console.log(&apos;Welcome to join wandoujia-fe&apos;)
    console.log(&apos;We want you&apos;)
&lt;/script&gt;
</code></pre><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>以 ()来分割属性</p>
<pre><code>a(rel=&quot;nofollow&quot;, href=&quot;http://www.wandoujia.com/join#getJobInfo=1&quot;) 招聘
</code></pre><p>会转换为：</p>
<pre><code>&lt;a rel=&quot;nofollow&quot; href=&quot;http://www.wandoujia.com/join#getJobInfo=1&quot;&gt;招聘&lt;/a&gt;
</code></pre><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释</p>
<pre><code>// changed by yc-team 
</code></pre><p>会转换为：</p>
<pre><code>&lt;!-- changed by yc-team --&gt;
</code></pre><p>多行注释</p>
<pre><code>body
//
  p 测试代码by yaochun
</code></pre><p>会转换为：</p>
<p><body><br><!--p 测试代码by yaochun 
--><br>    </body><br>不输出的注释</p>
<p>在单行注释上加一个短横线 -</p>
<pre><code>//- 这段注释不会输出
p 文本测试by yaochun
</code></pre><p>会转换为：</p>
<pre><code>&lt;p&gt;文本测试by yaochun&lt;/p&gt;
</code></pre><p>注意： 很多文档里面提到的条件注释已经不再支持</p>
<h3 id="doctype"><a href="#doctype" class="headerlink" title="doctype"></a>doctype</h3><p>添加一个doctype只需要doctype，然后再跟一个可选的值，默认是html</p>
<pre><code>doctype html
</code></pre><p>会转换为：</p>
<pre><code>&lt;!DOCTYPE html&gt;
</code></pre><p>注意!!!这种简写的方式已经被抛弃了~<br>可选值还有：</p>
<ul>
<li>xml</li>
<li>transitional</li>
<li>srict</li>
<li>frameset</li>
<li>1.1</li>
<li>basic</li>
<li>mobile</li>
</ul>
<h3 id="设置id或class"><a href="#设置id或class" class="headerlink" title="设置id或class"></a>设置id或class</h3><p>标签后面跟上<code>#id</code>,<code>.classname</code>，如果没有标签则使用默认标签div</p>
<pre><code>#content
p#info
a.btn
</code></pre><p>会转换为：</p>
<pre><code>&lt;div id=&quot;content&quot;&gt;&lt;/div&gt;
&lt;p id=&quot;info&quot;&gt;&lt;/p&gt;   
&lt;a class=&quot;btn&quot;&gt;&lt;/a&gt;
1个id和多个class
</code></pre><p>连着写即可</p>
<pre><code>a#download-btn.btn.blue-btn
</code></pre><p>会转换为：</p>
<pre><code>&lt;a id=&quot;download-btn&quot; class=&quot;btn blue-btn&quot;&gt;&lt;/a&gt;
</code></pre><h2 id="更多语法部分请查看jade学习"><a href="#更多语法部分请查看jade学习" class="headerlink" title="更多语法部分请查看jade学习"></a>更多语法部分请查看<a href="http://www.w3cplus.com/html/jade.html" target="_blank" rel="external">jade学习</a></h2>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[gulp及其相关插件的安卓与使用]]></title>
      <url>http://yoursite.com/2016/05/16/gulp%E5%8F%8A%E5%85%B6%E7%9B%B8%E5%85%B3%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E5%8D%93%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="gulp-js-基于流的自动化构建工具"><a href="#gulp-js-基于流的自动化构建工具" class="headerlink" title="gulp.js-基于流的自动化构建工具"></a><a href="http://www.gulpjs.com.cn/" target="_blank" rel="external">gulp.js</a>-基于流的自动化构建工具</h2><a id="more"></a>
<h2 id="gulp的插件库gulp-jspluginregistry"><a href="#gulp的插件库gulp-jspluginregistry" class="headerlink" title="gulp的插件库gulp.jspluginregistry"></a>gulp的<a href="http://gulpjs.com/plugins/" target="_blank" rel="external">插件库</a>gulp.jspluginregistry</h2><h3 id="gulp插件的安装"><a href="#gulp插件的安装" class="headerlink" title="gulp插件的安装"></a>gulp插件的安装</h3><p>代码如下： </p>
<pre><code>$ sudo npm install gulp -g 
</code></pre><p>进入项目的的文件夹后初始化开发依赖的的josn文件：</p>
<pre><code>$ npm int
</code></pre><p>然后设置相关配置后进行一些常用插件的安装，如jsmin，cssmin，jsconcat：</p>
<pre><code>$ npm install gulp-jsmin --save-dev
</code></pre><p>其他插件的安装和上边一样；</p>
<h3 id="配置gulp任务和参数"><a href="#配置gulp任务和参数" class="headerlink" title="配置gulp任务和参数"></a>配置gulp任务和参数</h3><p>在目标文件夹中，创建一个叫gulpfile.js的文件</p>
<p>打开文件编辑，通过gulp.task()来建立任务进程，</p>
<p>其中三个参数分别是<code>任务名</code>,<code>任务依赖</code>，<code>回调</code>;</p>
<pre><code>var gulp =require(&apos;gulp&apos;);
var jsmin = require(&apos;gulp-jsmin&apos;);
var cssmin    = require(&apos;gulp-cssmin&apos;);
var concat = require(&apos;gulp-concat&apos;);

gulp.task(&apos;default&apos;,function () {
console.log(&apos;hahahha&apos;);
})
gulp.task(&apos;jsmin&apos;,function(){
gulp.src(&apos;js/index.js&apos;)
.pipe(jsmin())
.pipe(gulp.dest(&apos;desk/index.js&apos;))
})
</code></pre><p>gulp.src() </p>
<pre><code>    目标文件
gulp.dest
    目标输出
pipe()
    管道，上面的输出就是下面的输入
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[实现框内的图片居中（商品图片常用）]]></title>
      <url>http://yoursite.com/2016/05/13/%E5%AE%9E%E7%8E%B0%E6%A1%86%E5%86%85%E7%9A%84%E5%9B%BE%E7%89%87%E5%B1%85%E4%B8%AD%EF%BC%88%E5%95%86%E5%93%81%E5%9B%BE%E7%89%87%E5%B8%B8%E7%94%A8%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>在一些场景中，我们经常要用到对一些未知尺寸的照片进行居中显示，例如购物网站的商品详情图片展示中，这时候要求我们对图片进行处理以适应这个展示窗口；<br><a id="more"></a></p>
<h2 id="margin值实现"><a href="#margin值实现" class="headerlink" title="margin值实现"></a>margin值实现</h2><p>我们采用了将图片转化为块标签的方式来用margin值来实现<br>具体代码下边展示:</p>
<pre><code>&lt;style type=&quot;text/css&quot;&gt;
    *{
        margin: 0;
        padding: 0;
     }
    .box{
        border: 1px solid black;
        height: 300px;
        width: 400px;
        }

    img{
        /*margin: 0 auto;*/
        display: block;
        margin: 0 auto;
        height: 100%;
        width: auto;
        }
&lt;/style&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[三分栏的自适应设计]]></title>
      <url>http://yoursite.com/2016/05/12/%E4%B8%89%E5%88%86%E6%A0%8F%E7%9A%84%E8%87%AA%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1/</url>
      <content type="html"><![CDATA[<p>我们在编辑布局的时候去实现三栏布局，左右两侧随着屏幕的宽度的变化自适应变化，中间的一栏固定宽度不变，我们采用了伪元素的方式来实现。分别采用::befroe和::after伪元素来实现左右两栏的填充，<br><a id="more"></a></p>
<h2 id="用伪元素实现三栏的流式布局"><a href="#用伪元素实现三栏的流式布局" class="headerlink" title="用伪元素实现三栏的流式布局"></a>用伪元素实现三栏的流式布局</h2><p>具体示例代码如下所示：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
&lt;meta charset=&quot;UTF-8&quot;&gt;
&lt;title&gt;Document&lt;/title&gt;
&lt;style&gt;
*{
    margin: 0;padding: 0
}
ul{
    list-style: none;
}
.head{
    position: fixed;top: 0;width: 100%
}
.nav{
width: 875px;height: 75px;position: relative;
margin: 0 auto;
}
ul{
background: darkgray;width: 800px;
float: left;height: 75px
}
img{
    float: left;
}
.nav::before{
    content: &apos;&apos;;
    width: 100%;
    height: 75px;
    position: absolute;
    left: -100%;background: purple;
    top: 0
}
.nav::after{
    content: &apos;&apos;;
    width: 100%;
    position: absolute;
    right: -100%;background-color:burlywood;
    top: 0;
    height: 75px;
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;div class=&quot;head&quot;&gt;
    &lt;div class=&quot;nav&quot;&gt;
        &lt;div&gt;
            &lt;img src=&quot;../1.png&quot; alt=&quot;&quot;&gt;
        &lt;/div&gt;
        &lt;div&gt;
            &lt;ul&gt;
                &lt;li&gt;&lt;/li&gt;
                &lt;li&gt;&lt;/li&gt;
                &lt;li&gt;&lt;/li&gt;
                &lt;li&gt;&lt;/li&gt;
                &lt;li&gt;&lt;/li&gt;
            &lt;/ul&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[标签语义化]]></title>
      <url>http://yoursite.com/2016/05/12/%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[伪元素的使用]]></title>
      <url>http://yoursite.com/2016/05/12/%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>  伪元素是创造关于文档语言能够指定的文档树之外的抽象。  例如文档语言不能提供访问元素内容第一字或者第一行的机制。伪元素允许设计师引用它们，否则这是难以办到的。伪元素还提供样式设计师给在源文档中不存在的内容分配样式（例如：:before和:after能够访问产生的内容）。<br><a id="more"></a></p>
<h2 id="常用的伪元素的种类"><a href="#常用的伪元素的种类" class="headerlink" title="常用的伪元素的种类"></a>常用的伪元素的种类</h2><ul>
<li>::before  </li>
<li>:: after</li>
<li>::first-line</li>
<li>::first-letter</li>
<li>::selector</li>
</ul>
<h2 id="伪元素的语法"><a href="#伪元素的语法" class="headerlink" title="伪元素的语法"></a>伪元素的语法</h2><pre><code>p:first-line  
  {
  color:#ff0000;  
  font-variant:small-caps;  
  }
</code></pre><h2 id="伪元素的定义"><a href="#伪元素的定义" class="headerlink" title="伪元素的定义"></a>伪元素的定义</h2><p><strong>注释：</strong>“W3C” 列指示出该属性在哪个 CSS 版本中定义（CSS1 还是 CSS2）。</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>::first-letter</td>
<td>向文本的第一个字母添加特殊样式。</td>
<td>1</td>
</tr>
<tr>
<td>::first-line</td>
<td>向文本的首行添加特殊样式。</td>
<td>1</td>
</tr>
<tr>
<td>::before</td>
<td>在元素之前添加内容</td>
<td>2</td>
</tr>
<tr>
<td>::after</td>
<td>在元素之后添加内容</td>
<td>2</td>
</tr>
</tbody>
</table>
<p><strong>注释</strong></p>
<p>“first-line”和”first-letter”可以用于得到属性</p>
<ul>
<li>font</li>
<li>color</li>
<li>background</li>
<li>margin</li>
<li>padding</li>
<li>border</li>
<li>text-decoration</li>
<li>vertical-align (仅当 float 为 none 时)</li>
<li>text-transform</li>
<li>line-height</li>
<li>float</li>
<li>clear</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于前端的思考与感悟]]></title>
      <url>http://yoursite.com/2016/05/12/%E5%85%B3%E4%BA%8E%E5%89%8D%E7%AB%AF%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%8E%E6%84%9F%E6%82%9F/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章应该道出很多人的心声了。不急慢慢看，会扣住你的心。5月2号了，5月20号还会远吗？今天我们就来看看由@看不懂未来对前端的感悟与思考。<br><a id="more"></a><br>正文从这开始～</p>
<p>万事开头难。<br>当我想要认真写一篇文章向大家分享我对前端的认识与感悟的时候，突然就深刻的体会到了这句话确实太有道理了。</p>
<p>最近几年对于web前端的传闻很多，比如人才稀缺，简单易学，待遇丰厚，整体势头发展良好等等。遇到过一个不太熟搞后台开发的同事跑来问我学习前端需要掌握哪些内容，也听说过一个搞IOS开发准备自学前端半个月然后要去找前端工作，也曾看到过有人对前端市场人才的稀缺这样吹捧过：<br>现在，几乎整个互联网行业都缺前端工程师，不仅在刚起步的创业公司，对上市公司乃至巨头这个问题也一样存在。没错，优秀的前端工程师简直比大熊猫还稀少。<br>… …</p>
<p>不仅在国内的互联网行业，在国外，前端工程师一样是需求旺盛、供不应求的香饽饽。</p>
<p>对于这样的吹捧，不反对也不支持。因为由于每个人的位置，经历的不同，对事总会有不同层面的理解。而作为一个从成都的菜鸟，蜕变成一名北京的菜鸟，也来谈谈自己对于前端的理解。</p>
<h2 id="一、地域差异"><a href="#一、地域差异" class="headerlink" title="一、地域差异"></a>一、地域差异</h2><p>在成都的大部分公司，有一种专门负责切图排版的网页工程师。他们需要懂一些PS，然后会使用HTML与CSS排版。而这类人往往是刚参加工作不久的毕业生，响应式布局对他们来说是一种高大上的技能。很荣幸，我也曾经是他们的一员，也正因为如此，我掌握着熟练的切图技巧，而这个层次，可能就是外人认为的入门容易吧，然而实际上还差很远很远。</p>
<p>另外一种，就是比较厉害一点的程序员。他们会js+一门后端语言，比如php，jsp。但是他们会会更加偏向后端一点，他们将html,css,js当成一种很基本的东西，更多的逻辑都使用后端语言来处理，并不会那么清晰的将html页面与后端语言分离开来。所以我们常常会看到有的页面以.php，.jsp结尾。</p>
<p>来了北京之后，才算是见识了真正的web前端。以至于常常会有一种恨自己为什么不早一点来的感觉，恍如隔世。随着学习的慢慢提升，会感觉到北京的前端更加具有明确的方向。</p>
<p>我们会真正的注重用户体验，所以每个页面都会响应式布局，从PC端适配到最小320px宽度的移动端，更加注重html5/css3的相关知识的运用，也会为了用户体验做很多功能之外的更加合理的处理。会真的很认真的考虑面试中常常会问的如何优化前端性能。因此我们使用gulp+require来构建前端代码，压缩，打包，上传cdn。</p>
<p>总的来说，在北京，前端更加专业与明确一点，发展更加好一点。</p>
<h2 id="二、兴趣是否重要？"><a href="#二、兴趣是否重要？" class="headerlink" title="二、兴趣是否重要？"></a>二、兴趣是否重要？</h2><p>我曾经很认真的思考过这个问题，很多前辈大神告诉我，“兴趣很重要。”</p>
<p>可是我经过仔细分析自身的情况之后，却得出了一个相反的结论。</p>
<p>因为我并没有发现什么东西是我感兴趣、并且能让我能够混口饭吃的。然后现在我也觉得只要我能够这样慢慢努力下去，在前端这个行业里，还是能够拥有一席之地。现实一点来说，只要你能够进下心来不排斥它，你就可以选择它。毕竟人都是要吃饭，要养活自己的，我想大多数人都是没办法指着自己的兴趣过活的。</p>
<p>《一万小时天才理论》告诉我们，在某一个方向专注一万小时，你就能够成为这个方向的专家。我认为，这个道理，在前端也同样适用，专注，比兴趣更加重要。</p>
<h2 id="三、什么心态会影响自己的进步？"><a href="#三、什么心态会影响自己的进步？" class="headerlink" title="三、什么心态会影响自己的进步？"></a>三、什么心态会影响自己的进步？</h2><p>不坚定。<br>至少我现在可以肯定的是，前端方向，并不是一个糟糕的选择。在最初的时候，时常会在UI设计与前端之间摇摆不定。我认为我对UI设计更加感兴趣一点。特别是参与了电信一个视频播放app的设计之后，更是认为自己未来是有机会成为一名优秀的UI设计师。但是我另外又觉得自己在前端方向会更加快一点提升自己。于是在很长一段时间里就纠结在这个问题上摇摆不定，停滞不前。其实不管坚定的选择哪一个方向，在目前的互联网行业里，都是很热门的选择，都有出头之日。而最大的错误就在于，犹豫不决。</p>
<p>浮躁。<br>如果我最终没能成为一名优秀的前端工程师，那么最大的原因肯定就是心态的浮躁。</p>
<p>谁都想要在短期内成为一名学识渊博，经验丰富，德高望重的前端工程师。我也想，这是很难避免的一个心态问题，别人高额的薪水与自己的困境总是那么轻易的扰乱心神。所以一个月从入门到精通，3个月从入门到精通之类的宣传标语，都是非常受欢迎。然而事实上，这并不可能。打着这些宣传标语的培训机构，最多只能带你入门。甚至很有可能一位在前端行业沉浮好几年的老同学都不敢说自己已经在这个行业算得上优秀了。并不是说几年的时间没办法变得优秀，而是能够静下心来潜心修炼的人确实凤毛麟角。所以其实实际情况是慢慢来，才最快</p>
<p>毕业几年，感觉自己前进道路上最大的阻碍就是这两个心态问题。这也正是我开公众号的初衷所在，我希望能够静下心来，将自己学到的东西整理出来，分享给大家，一来慢慢竖立自己的个人品牌，让别人能够更加简单直接的了解自己，二来也锻炼自己的心态。在这里也谢谢大家的关注与支持。</p>
<h2 id="四、-如何应对新技术层出不穷的现状"><a href="#四、-如何应对新技术层出不穷的现状" class="headerlink" title="四、 如何应对新技术层出不穷的现状"></a>四、 如何应对新技术层出不穷的现状</h2><p>很多时候我都会觉得前端对于新人来说其实挺过分的。</p>
<p>想要学习一门ui框架，有什么easyui，bootstrap，Foundation等等。想要搞一个自己的静态博客，有什么wordpress，jekyll，hexo等等</p>
<p>想要学构建工具，有什么grunt，gulp，webpack等等</p>
<p>还有好多传说中都很厉害的库，jQuery，angular，vue，react等等</p>
<p>真的眼花缭乱，刚开始怎么分得清谁比谁好啊。一不小心就走一大堆的弯路。<br>所以这个时候我们就必须明白一个道理。基础的重要性在于，他能够提高我们的学习能力。</p>
<p>bootstrap，angularjs最初于我如传说中的存在，高不可攀。而且很多公司招人都希望员工能够掌握这些技术。所以在基础很薄弱的时候就开始尝试去学习。很显然，效果是几乎没有的。反而会减少我对于前端的自信，会很容易产生动摇，觉得自己不适合。</p>
<p>可是随着基础的慢慢提升，我发现要掌握bootstrap与angularjs似乎也没有那么难。我甚至能够看着文档就有模有样的将这些技术运用起来。这对于以前的我来说，简直就是不可思议。</p>
<p>因此，从以前的高不可攀，到现在的触手可及，让我明白了基础的重要性。<br>而对于最近非常火的react，webpack等，掌握起来也没有当初那种无法触及的感觉。这些技术之所以能火，就说明能够学会的人很多，他并不存在特别难以掌握的瓶颈。如果你的基础够牢靠，你就是这些技术的弄潮儿。</p>
<h2 id="五、前端并没有那么简单"><a href="#五、前端并没有那么简单" class="headerlink" title="五、前端并没有那么简单"></a>五、前端并没有那么简单</h2><p>前端不简单的地方，并不在于知识点的掌握，技术的实现，而在于寻找更优解。即使是最简单的页面布局，也存在层出不穷的优秀解决方案，比如在大学的时候，常用table元素来实现几乎所有的页面布局，到现在理解文档流，会运用浮动，各种盒模型，BFC等来实现布局这中间的差距对于一个新人来说是非常巨大的。</p>
<p>从最初的写一大堆js代码，实现一个页面的小功能，到后来发现有的人只需要用几行代码配合html/css就可以控制整个页面的所有动画，这中间的差距，也是非常巨大的。所以前端并不是外界认为的那么简单，甚至并不比掌握好一门后端程序语言那么容易。所以我们要保持敬畏之心。</p>
<h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><p>学习方法<br>在我这个阶段的认识来看，我认为学习最靠谱的方法就是积累。有一个很普遍的假象是，互联网时代似乎获取知识越来越容易，很多人都在担忧所谓的信息过剩的问题。然而实际情况却是，我们更加难以捕捉到对我们来说真正有用的信息。而前端的知识相对而言更加零散与碎片化，并且越来越多样化，所以知识的积累则是一个非常重要的过程。</p>
<p>英语很重要<br>英语很重要的原因是因为国外的技术比我们发达，我们常常需要阅读国外的文章来提升自己，也常常需要在google搜索上找到自己问题的答案</p>
<p>总的来说，在前端的道路上，遇到过动摇，困惑，迷茫。也因为浮躁的心态停滞不前。好在都一步一步的走了过来。并且可以很把握的告诉自己，这个方向，不会亏待我的付出与努力。</p>
<p>花了很多时间，终于把这篇文章写完了，泪奔！写文章对于一个程序员来说真的是超级大的挑战。感悟就是万事开头难，中间难，结尾也难。</p>
<p>后语<br>看完这篇，你的关键词是什么呢？你是属于哪一种呢？</p>
<p>关于本文<br>作者：@<a href="https://segmentfault.com/a/1190000004976918" target="_blank" rel="external">看不懂未来</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[git仓库的搭建]]></title>
      <url>http://yoursite.com/2016/05/12/git%E4%BB%93%E5%BA%93%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
      <content type="html"><![CDATA[<p>Git是一个分布式的版本控制系统，最初由Linus Torvalds编写，用作Linux内核代码的管理。在推出后，Git在其它项目中也取得了很大成功，尤其是在Ruby社区中。目前，包括Rubinius、Merb和Bitcoin在内的很多知名项目都使用了Git。Git同样可以被诸如Capistrano和Vlad the Deployer这样的部署工具所使用。<br><a id="more"></a></p>
<p></p><h2>git仓库的搭建</h2> <!--more--><br> <h3>创建<a href="https://github.com/" target="_blank" rel="external">github</a>账号</h3>  <img src="http://i4.buimg.com/ccf9a78c639294ce.jpg" alt="zhuce"><p></p>
<p></p><h3>新建一个repositories仓库</h3>  <img src="http://i4.buimg.com/0ddd0201c18ef377.jpg"><p></p>
<p></p><h3>设置ssh-keygen</h3><p></p>
<p></p><h3>vim获取Keygen</h3><code>$ vim ~/.ssh/id_rsa.pub</code><p></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Phane主题的使用]]></title>
      <url>http://yoursite.com/2016/05/11/Phane%E4%B8%BB%E9%A2%98%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h2 id="主题概括"><a href="#主题概括" class="headerlink" title="主题概括"></a>主题概括</h2><p>acman是一款为Hexo打造的一款扁平化，有着响应式设计的主题。本站正是为该主题设计的演示站点，同时你也可以访问<a href="http://changxinle.github.io/" target="_blank" rel="external">我的博客</a>查看效果。主题源码托管在Github上，欢迎Fork。遇到任何问题或意见请发表issue。<br><a id="more"></a></p>
<h2 id="安装指南"><a href="#安装指南" class="headerlink" title="安装指南"></a>安装指南</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/A-limon/pacman.git themes/pacman</span><br><span class="line">```  </span><br><span class="line">&lt;br&gt;</span><br><span class="line">Pacman需要安装Hexo 2.4.5 或以上版本 请先升级您的Hexo程序，再启用此主题。</span><br><span class="line"></span><br><span class="line">### 启用</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">修改你的博客根目录下的`config.yml`配置文件中的theme属性，将其设置为`pacman`。同时请设置`stylus`属性中的`compress`值为`true`。</span><br><span class="line"></span><br><span class="line">### 更新</span><br><span class="line">```  cd themes/pacman      </span><br><span class="line">	git pull</span><br></pre></td></tr></table></figure>
<h2 id="配置指南"><a href="#配置指南" class="headerlink" title="配置指南"></a>配置指南</h2><p>Pacman主题提供了丰富的配置属性，配置文件<code>_config.yml</code>位于主题根目录下。配置文件中已经包含了详细的英文注释，所以下面就用中文进行说明。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><pre><code>##### Menu
menu:
  主页: /
  存档: /archives
   # 分类: /tags (or categories)

## you can create `tags` and `categories` folders in `../source`.
## And create a `index.md` file in each of them.
## set `front-matter`as
# layout: tags (or categories)
# title: tags (or categories)
## ---

#### Widgets
widgets: 
- category
- tag
- rss
## provide six widgets:category,tag,rss,archive,tagcloud,links.
## modify links in `/layout/_widget/links.ejs`.

#### RSS
rss: ## RSS address.

#### Image
imglogo:
  enable: true             ## display image logo true/    false.
  src: img/logo.svg        ## `.svg` and `.png` are recommended,please put image into the theme folder `/pacman/source/img`.
favicon: img/favicon.ico   ## size:32px*32px,`.ico` is recommended,please put image into the theme folder `/pacman/source/img`.     
apple_icon: img/pacman.jpg ## size:114px*114px,please put image into the theme folder `/pacman/source/img`.

#### Author Avatar Picture
author_img_enable: true ## display author avatar picture
dataURI: false
## if the picture&apos;s format is dataURI please set the value to true,otherwise set the value to false.
## convert an image into base 64 data URIs http://websemantics.co.uk/online_tools/image_to_data_uri_convertor/ .
author_img_data: &apos;&apos;
## paste the dataURI in ONE LINE and included it by &apos;&apos;.
author_img: img/author.jpg ## size:220px*220px.
## if the picture&apos;s format is `.png` or `.jpg`  instead of dataURI,you should set the `dataURI` value to false.

#### Font
ShowCustomFont: true  
## you can change custom font in `variable.styl` and `font.styl` which in the theme folder `/pacman/source/css`.

#### Toc
toc:
article: true   ## show contents in article.
aside: true     ## show contents in aside.
## you can set both of the value to true of neither of them.
## if you don&apos;t want display contents in a specified post,you can modify `front-matter` and add `toc: false`.

#### Fancybox
fancybox: false 
## if you use gallery post or want use fancybox please set the value to true.
## if you want use fancybox in ANY post please copy the file `fancybox.js`.
## in theme folder `/pacman/scripts` to your hexo blog folder `../scritps`.

#### Author information
author:
  google_plus:    ## eg:116338260303228776998 for https://plus.google.com/u/0/116338260303228776998
  intro_line1: &quot;&quot; ## eg: &quot;Hello ,I&apos;m Larry Page in Google.&quot;
  intro_line2: &quot;&quot; ## eg: &quot;This is my blog,believe it or not.&quot;
  weibo:      ## e.g. 436062867 for http://weibo.com/436062867
  twitter:    ## e.g. yangjiansky for https://twitter.com/yangjiansky
  github:     ## e.g. A-limon for https://github.com/A-limon
facebook:   ## e.g. yangjian for https://favebook.com/yangjian
tsina:      ## e.g. 1664838973  Your weibo ID,It will be used in share button.
linkedin:   ## e.g. in/jeffweiner08 for https://www.linkedin.com/in/jeffweiner08

#### Comment
duoshuo: 
enable: true  ## duoshuo.com
short_name:    ## duoshuo short name.

#### Share button
jiathis:
  enable: false ## if you use jiathis as your share tool,the built-in share tool won&apos;t be display.
id:    ## e.g. 1501277 your jiathis ID. 
tsina: ## e.g. 1664838973 Your weibo id,It will be used in share button.

#### Analytics
google_analytics:
  enable: false
  id:   ## e.g. UA-1766729-8 your google analytics ID.
  site: ## e.g. yangjian.me your google analytics site or set the value as auto.
## You MUST upgrade to Universal Analytics first!
## https://developers.google.com/analytics/devguides/collection/upgrade/?hl=zh_CN

#### Custom Search
google_cse: 
enable: false
cx:  ## e.g. 000561263943549425496:mrzrm0gr4kg your Custom Search ID
## https://www.google.com/cse/ 
## To enable the custom search You must create a &quot;search&quot; folder in &apos;/source&apos; and a &quot;index.md&quot; file
## set the &apos;front-matter&apos; as
## layout: search 
## title: search
## ---
</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li><p>menu 默认没有启用 <code>/tags</code> 和 <code>/categories</code> 页面，如果需要启用请在博客目录下的<code>source</code>文件夹中分别建立<code>tags</code>和 <code>categories</code>文件夹每个文件夹中分别包含一个<code>index.md</code>文件。内容为：</p>
<pre><code>layout: tags (或categories)
title: tags (或categories)
---
</code></pre></li>
</ul>
<p>因为主题中已经内置了这两个页面的模板，所以他们会被正确的解析出来。</p>
<ul>
<li>widgets: 提供了6种小工具。</li>
<li>rss: 请填写你博客的RSS地址。</li>
<li>imglogo: 建议启用图片logo，格式建议为.svg或.png格式。同时建议提供配套的favicon以及在苹果设备上的图标（背景不要透明）。</li>
<li>author_img_enable: 是否显示底部的作者头像。主题支持头像使用dataURI格式，若使用请修改dataURI的值为true并在下面的 -author_img_data后填上图片的值，确保它是一行而且被引号包住如果还是想用传统的jpg格式那么就把图片路径放在author_img后，同时把dataURI设置成false。</li>
<li>ShowCustomFont: 启用自定义字体，如果你有一定前端基础可以修改font.styl替换为你喜欢的字体。</li>
<li>toc: 是否启用在文章中或侧边栏中的目录功能。二者可以都为true或都为false。同时，如果你希望在特定的某一篇文章中关闭目录功能你可以在文章文件开头中的front-matter中加上一行toc: false。<br>fancybox: 默认关闭，如果你使用Hexo经常发表Gallery类型的文章，那么请设置为true（同时需要复制fancybox.js到你的博客目录下scripts文件夹中）。ps: 我很佩服用Hexo发表相册的文艺青年。</li>
<li>author: 作者信息，建议尽量填写完整。其中tsina是你的新浪微博ID，不同于用户名或微博主页地址。启用这个属性后，其他用户在微博上分享你文章的同时会自动@你。</li>
<li>duoshuo: 多说评论系统。在大陆地区更好用的评论系统，如果你想更换为disqus请参考默认主题后自行修改。</li>
<li>jiathis: 加网分享系统。默认关闭，因为主题已经内置了原生的分享功能。<br>google_analytics: Google Analytics追踪代码。请注意：*Google Analytics已经升级到了Universal Analytics。请先前往后台升级你的Google Analytics版本后再启用追踪代码 更多信息请点击这里了解。</li>
<li>google_cse: Google自定义搜索。如果开启自定义搜索需要先登录Google CSE，配置好你的站点，并获得此自定义搜索的ID。此外你需要在博客目录下的source文件夹中建立search文件夹并包含一个index.md文件。内容为：  <pre><code><figure class="highlight plain"><figcaption><span>search</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```  </span><br><span class="line">```title: search  </span><br><span class="line">```  </span><br><span class="line">```---</span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
]]></content>
    </entry>
    
  
  
</search>
